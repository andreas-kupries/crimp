merge
Tcl_Obj* imageListObj

int objc;
Tcl_Obj **objv;
if (Tcl_ListObjGetElements(interp, imageListObj, &objc, &objv) != TCL_OK) {
    return TCL_ERROR;
} else if (objc == 0) {
    Tcl_SetResult(interp, "must have at least one image", TCL_STATIC);
    return TCL_ERROR;
}

unsigned char (*in[objc])[][4];
int w, h, i;
if (decodeImageObj(interp, objv[0], &w, &h,
        (unsigned char **)&in[0]) != TCL_OK) {
    return TCL_ERROR;
}
for (i = 1; i < objc; ++i) {
    int w2, h2;
    if (decodeImageObj(interp, objv[i], &w2, &h2,
            (unsigned char **)&in[i]) != TCL_OK) {
        return TCL_ERROR;
    } else if (w != w2 || h != h2) {
        Tcl_SetResult(interp, "images must have same size", TCL_STATIC);
        return TCL_ERROR;
    }
}

Tcl_Obj *resultObj, *dataObj;
if (getUnsharedImageObj(interp, objv[0], &resultObj, &dataObj) != TCL_OK) {
    return TCL_ERROR;
}

unsigned char (*out)[][4] = (unsigned char (*)[][4])
        Tcl_GetByteArrayFromObj(dataObj, NULL);
int j, c;
for (j = 1; j < objc; ++j) {
    for (i = 0; i < w * h; ++i) {
        for (c = 0; c < 3; ++c) {
            (*out)[i][c] = ((*in[j])[i][c] * (*in[j])[i][3]
                          + (*out)[i][c] * (255 - (*in[j])[i][3])) / 255;
        }
        (*out)[i][3] = (*out)[i][3] + (*in[j])[i][3]
                     - (*out)[i][3] * (*in[j])[i][3] / 255;
    }
}
Tcl_SetObjResult(interp, resultObj);
return TCL_OK;

/* vim: set sts=4 sw=4 tw=80 et ft=c: */
