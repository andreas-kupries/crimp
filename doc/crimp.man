[comment {-*- tcl -*- doctools manpage}]
[manpage_begin crimp n 1.0.1]
[copyright {2010 Andreas Kupries}]
[copyright {2010 Documentation, Andreas Kupries}]
[moddesc   {Image Manipulation}]
[titledesc {Image Manipulation (not yet independent of Tk)}]
[require Tcl 8.5]
[require Tk 8.5]
[require crimp [opt 1]]
[description]

This package provides image manipulation commands which are mostly
independent of Tk. The only parts currently depending on Tk are for
the import and export of images from and to Tk photos, necessary for
display.

[para]

Note that the intended audience of this document are the users of
[package crimp]. Developers wishing to work on the internals of the
package, but unfamiliar with them, should read ... instead.

[section Images]

Images are values. This means that they have a string
representation. It is however strongly recommended to not access this
representation at all, and to only use the accessor commands provided
by crimp to obtain the information stored in the internal
representation of image values.

[para]

The reason behind this is simple: Memory and speed. Images can be
large. Generating the string representation from the internal one
roughly doubles the memory needed to store it, actually a bit more,
due to the necessary quoting of bytes in UTF-8 and list-quting them as
well. Furthermore such a conversion takes time, roughly proportional
to the size of the image itself, in either direction. Properly
accessing the image information without the package's accessor
commands requires list commands. This causes the loss of the internal
representation, thus forcing later a reconversion to the image's
internal represention when it is used as image again. I.e. the
shimmering forces us to convert twice.

[para]

Therefore, avoid this, use only the crimp commands to access the
images. The only part of them you are not able to access through these
is the pixel data. And requiring access to that in a Tcl script is,
IMHO, highly unusual. In such a situation it is likely better and
easier to simply become a developer and extend the C level parts of
crimp with the operation which would have required that access.

[section {Image Types}]

Each image has a [term type], a string implicitly describing features
like the colorspace the image is in, the number of (color) channels,
the domain, i.e. bit-depth, of pixel values in the channels, etc.

[para]

All type strings have the form [const crimp::image::][var foo].

[para]

The package currently knows the following types:

[list_begin definitions]
[def [const rgba]]
	[list_begin definitions]
	[def Colorspace]	RGB also known as Red, Green, and Blue.
	[def Channels]		4, named "red", "green", and "blue",
				plus an "alpha" channel controlling
				pixel opacity.
	[def Bit-depth]		1 byte/channel (8 bit, values 0-255).
	[def Pixel-size]	4 bytes.
	[list_end]
[def [const rgb]]
	[list_begin definitions]
	[def Colorspace]	RGB also known as Red, Green, and Blue.
	[def Channels]		3, named "red", "green", and "blue".
	[def Bit-depth]		1 byte/channel (8 bit, values 0-255).
	[def Pixel-size]	3 bytes.
	[list_end]
[def [const hsv]]
	[list_begin definitions]
	[def Colorspace]	HSV, also known as Hue, Saturation, and Value.
	[def Channels]		3, named "hue", "saturation", and "value".
	[def Bit-depth]		1 byte/channel (8 bit, values 0-255).
	[def Pixel-size]	3 bytes.
	[list_end]
[def [const grey8]]
	[list_begin definitions]
	[def Colorspace]	Greyscale.
	[def Channels]		1, named "luma".
	[def Bit-depth]		1 byte/channel (8 bit, values 0-255).
	[def Pixel-size]	1 byte.
	[list_end]
[def [const grey16]]
	[list_begin definitions]
	[def Colorspace]	Greyscale.
	[def Channels]		1, named "luma".
	[def Bit-depth]		2 byte/channel (16 bit, values 0-65,535).
	[def Pixel-size]	2 bytes.
	[list_end]
[def [const grey32]]
	[list_begin definitions]
	[def Colorspace]	Greyscale.
	[def Channels]		1, named "luma".
	[def Bit-depth]		4 byte/channel (16 bit, values 0-4,294,967,296).
	[def Pixel-size]	4 bytes.
	[list_end]
[def [const bw]]
	[list_begin definitions]
	[def Colorspace]	Binary.
	[def Channels]		1, named "bw".
	[def Bit-depth]		1 bit/channel.
	[def Pixel-size]	1 byte. I.e. 7 bits/channel are wasted.
	[list_end]
[list_end]

Support for the various types varies by operation. The exact image
types supported by each operation are listed the operation's
description. Invoking an operation for a type it doesn't support will
generally cause it to throw an error.


[section {General design}]

All commands operate in a pipeline fashion, taking zero or more image
values, zero or more other arguments, and returning zero or more
images or other values. None are operating in place, i.e. taking an
image variable and writing back to it.

[para]

They fall, into five categories, namely:

[list_begin definitions]
[def Accessors]

They take one or more images, extract information about them, and
return this information as their result. This can be a simple as
querying the image's height, to something as complex as counting pixel
values for a histogram.

[para]

The list of accessors, their syntax, and detailed meaning can be found
in section [sectref Accessors].


[def Manipulators]

These take an image and transform its contents in some way, leaving
the image type unchanged. Examples of commands in category are
inversion, gamma conversion, etc.

[para]

The list of manipulators, their syntax, and detailed meaning can be
found in section [sectref Manipulators].


[def Converters]

Similar to manipulators, except that they change the image's type,
preserving the content instead. Here reside operations like conversion
between the HSV and RGB colorspaces, to greyscale and back, etc.

[para]

The list of converters, their syntax, and detailed meaning can be
found in section [sectref Converters].


[def I/O]

Another variant of the same theme, i.e. akin to converters and
manipulators, yet not the same, these commands read and write images
from and to files or other data structures. I.e. they convert between
different serializations of image content and type.

[para]

The list of I/O commands, their syntax, and detailed meaning can be
found in section [sectref {I/O commands}].


[def Support]

Lastly, but not leastly a number of commands, which, while not image
commands themselves, support the others.

[para]

The list of supporting commands, their syntax, and detailed meaning
can be found in section [sectref Support].


[list_end]


[section API]
[subsection Accessors]
[list_begin definitions]
[call [cmd ::crimp] [method channels] [arg image]]

This method returns a list containing the names of the channels in the
[arg image]. The order of channels is the same as expected by the
[method remap] method.

[para] The method supports all image types.


[call [cmd ::crimp] [method dimensions] [arg image]]

This method returns the width and height of the [arg image] (in pixels).
The result is a 2-element list containing width and height, in this order.

[para] The method supports all image types.


[call [cmd ::crimp] [method height] [arg image]]

This method returns the height of the [arg image] (in pixels).

[para] The method supports all image types.


[call [cmd ::crimp] [method histogram] [arg image]]

This method returns a nested dictionary as its result.
The outer dictionary is indexed by the names of the
channels in the [arg image]. Its values, the inner
dictionaries, are indexed by pixel value. The associated
values are the number of pixels with that value.

[para] The method supports all image types except "grey32".
Under the current system the result would be a dictionary
with 2^32 keys and values, taking up, roughly, 192 GiByte of
memory in the worst case, and 96 GiByte in best case (all
counter values shared in a single object).


[call [cmd ::crimp] [method type] [arg image]]

This method returns the type of the [arg image].

[para] The method supports all image types.


[call [cmd ::crimp] [method width] [arg image]]

This method returns the width of the [arg image] (in pixels).
[para] The method supports all image types.

[list_end]


[subsection Manipulators]
[list_begin definitions]
[call [cmd ::crimp] [method blank] [arg type] [arg value]...]
[call [cmd ::crimp] [method blend] [arg foreground] [arg background] [arg alpha]]
[call [cmd ::crimp] [method degamma] [arg image] [arg y]]
[call [cmd ::crimp] [method gamma] [arg image] [arg y]]
[call [cmd ::crimp] [method invert] [arg image]]
[call [cmd ::crimp] [method matrix] [arg image] [arg matrix]]
[call [cmd ::crimp] [method over] [arg foreground] [arg background]]
[call [cmd ::crimp] [method psychedelia] [arg width] [arg height] [arg frames]]
[call [cmd ::crimp] [method remap] [arg image] [arg map]...]
[call [cmd ::crimp] [method setalpha] [arg image] [arg mask]]
[call [cmd ::crimp] [method solarize] [arg image] [arg threshold]]
[call [cmd ::crimp] [method wavy] [arg image] [arg offset] [arg adj1] [arg adjb]]
[call [cmd ::crimp] [method {flip horizontal}] [arg image]]
[call [cmd ::crimp] [method {flip transpose}] [arg image]]
[call [cmd ::crimp] [method {flip transverse}] [arg image]]
[call [cmd ::crimp] [method {flip vertical}] [arg image]]
[list_end]


[subsection Converters]
[list_begin definitions]
[call [cmd ::crimp] [method {convert 2grey8}] [arg image]]
[call [cmd ::crimp] [method {convert 2hsv}] [arg image]]
[call [cmd ::crimp] [method {convert 2rgba}] [arg image]]
[call [cmd ::crimp] [method {convert 2rgb}] [arg image]]
[call [cmd ::crimp] [method {join 2hsv}] [arg image]]
[call [cmd ::crimp] [method {join 2rgba}] [arg image]]
[call [cmd ::crimp] [method {join 2rgb}] [arg image]]
[call [cmd ::crimp] [method split] [arg image]]
[list_end]


[subsection {I/O commands}]
[list_begin definitions]
[call [cmd ::crimp] [method {read tcl}] [arg pixelmatrix]]
[call [cmd ::crimp] [method {read tk}] [arg photo]]
[call [cmd ::crimp] [method {write 2tk}] [arg photo] [arg image]]
[list_end]


[subsection Support]
[list_begin definitions]
[call [cmd ::crimp] [method map] [arg arg]...]

This method accepts the same sub-methods and arguments as are accepted
by the [method table] method below. In contrast to [method table]
the result is not a list of values, but a map image directly suitable
as argument to the [method remap] method.


[call [cmd ::crimp] [method {table degamma}] [arg y]]

This method returns a list of 256 values, the result of running
the values 0 to 255 through the [fun {inverse gamma correction}] with
parameter [arg y].

This inverse correction, defined in the domain of [lb]0..1[rb]
for both argument and result, is defined as:

[para][image gamma_inv][para]

Scaling of argument and result into the domain [lb]0..255[rb]
of pixel values, and rounding results to the nearest integer,
causes the actual definition used to be

[para][image scaled_gamma_inv]


[call [cmd ::crimp] [method {table gainw}] [arg gain] [arg bias]]

This method returns a list of 256 values, the result of running
the values 0 to 255 through a simple linear function with parameters
[arg gain] and [arg bias]. The results are rounded to the nearest
integer and forced into the domain [lb]0..255[rb] by wrapping them
around (modulo), making the definition:

[para][image linear_wrap]


[call [cmd ::crimp] [method {table gain}] [arg gain] [arg bias]]

This method is like [method gainw], except that it deals with results
out of the domain [lb]0..255[rb] by clamping them to 0 and 255
respectively instead of wrapping around. I.e. its definition is

[para][image linear_clamp]


[call [cmd ::crimp] [method {table gamma}] [arg y]]

This method returns a list of 256 values, the result of running
the values 0 to 255 through the [fun {gamma correction}] with
parameter [arg y].

This correction, defined in the domain of [lb]0..1[rb] for both
argument and result, is defined as:

[para][image gamma][para]

Scaling of argument and result into the domain [lb]0..255[rb]
of pixel values, and rounding results to the nearest integer,
causes the actual definition used to be

[para][image scaled_gamma]


[call [cmd ::crimp] [method {table identity}]]

This method returns a list of 256 values, the result of running
the values 0 to 255 through the [fun identity] function, defined as

[para][image identity]


[call [cmd ::crimp] [method {table invers}]]

This method returns a list of 256 values, the result of running
the values 0 to 255 through the [fun inverse] function, defined as

[para][image inverse]


[call [cmd ::crimp] [method {table solarize}] [arg threshold]]

This method returns a list of 256 values, the result of running
the values 0 to 255 through the [fun solarize] function, with
parameter [arg threshold]. The function is defined as:

[para][image solarize]
[para]

Note how the function is the [fun identity] for values under the
threshold, and the [fun inverse] for values at and above it.

[list_end]


[keywords photo image]
[manpage_end]

