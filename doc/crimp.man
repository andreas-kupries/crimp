[comment {-*- tcl -*- doctools manpage}]
[manpage_begin crimp n 0.1]
[include include/module.inc]
[titledesc {CRIMP - Manipulation and Processing}]
[require Tcl 8.5]
[require Tk 8.5]
[require crimp [opt 0.1]]
[require crimp::core [opt 0.1]]
[description]

This package, built on top of the [package crimp::core] package
provides the majority of CRIMPs power, manipulating and transforming
images in a number of ways.

[para] For a basic introduction of the whole CRIMP eco-system please read
the [term {CRIMP - Introduction to CRIMP}] (sic!).

The basic concepts used here, like images, image types, etc. are
described in the reference manpage for the [term {CRIMP - Foundation}].
We will not repeat them here, but assume that the reader knows them
already.

[para] In the overall architecture this package resides in the middle
layer of the system's architecture, between core and applications, as
shown at

[para][image arch_processing][para]

Note that the intended audience of this document are the users of
[package crimp]. Developers wishing to work on the internals of the
package, but unfamiliar with them, should read ... instead.

[section API]
[subsection Accessors]
[list_begin definitions]

[call [cmd ::crimp] [method histogram] [arg image]]
[keywords histogram]

This method returns a nested dictionary as its result.  The outer
dictionary is indexed by the names of the channels in the [arg image].
Its values, the inner dictionaries, are indexed by pixel value. The
associated values are the number of pixels with that value.

[para] The method supports all image types except "grey32".  Under the
current system the result would be a dictionary with 2^32 keys and
values, taking up, roughly, 192 GiByte of memory in the worst case,
and 96 GiByte in best case (all counter values shared in a single
object).

[call [cmd ::crimp] [method {statistics basic}] [arg image]]
[keywords statistics min max median mean average middle stddev variance]

This method returns a nested dictionary as its result. The outer dictionary
contains basic information about the image, see the list of keys below.
The inner dictionaries hold data about each (color) channel in the image,
namely histogram and derived data like minumum pixel value, maximum, etc.

[list_begin definitions]
[def [const dimensions]] 2-element list holding image width and height, in
                         this order.
[def [const height]]     Image height as separate value.
[def [const pixels]]     Number of pixels in the image, the product of
                         its width and height.
[def [const type]]       Type of the image.
[def [const width]]      Image width as separate value.
[def [const channels]]   List of the names for the channels in the image.
[def [const channel]]    A dictionary mapping the names of the image's
                         channels, as listed under key [const channels], to
                         a dictionary holding the statistics for that channel.
[list_begin definitions]
[def [const min]]        The minimal pixel value with a non-zero population.
[def [const max]]        The maximal pixel value with a non-zero population.
[def [const mean]]       The arithmetic mean (aka average) of pixel values.
[def [const middle]]     The arithmetic mean of the min and max pixel values.
[def [const median]]     The median pixel value.
[def [const stddev]]     The standard deviation of pixel values.
[def [const variance]]   The variance of pixel values, square of the standard
                         deviation.
[def [const histogram]]  A dictionary mapping pixel values to population counts.
[def [const hf]]         The histogram reduced to the population counts, sorted
                         by pixel value to direct indexing into the list by
                         pixel values.
[def [const cdf]]        The [term {cumulative density function}] of pixel
                         values. The discrete integral of [const hf].
[def [const cdf255]]     Same as [const cdf], except scaled down so that the
                         last value in the series is 255.
[list_end]
[list_end]

[para] The method supports all image types except "grey32".  Under the
current system the result would contain internal dictionaries with 2^32 keys
and values, taking up, roughly, 192 GiByte of memory in the worst case,
and 96 GiByte in best case (all counter values shared in a single
object).

[call [cmd ::crimp] [method {statistics otsu}] [arg stats]]
[keywords {otsu threshold} threshold binarization]

This method takes a dictionary of basic image statistics as generated
by [cmd {crimp statistics basic}] and returns an extended dictionary
containing a threshold for image binarization computed by Otsu's
method (See [sectref References reference] 2). Note that this
threshold is computed separately for each channel and stored in the
channel specific part of the dictionary, using the key [const otsu].

[list_end]


[subsection Manipulators]
[list_begin definitions]


[call [cmd ::crimp] [method add] [arg image1] [arg image2] [opt [arg scale]] [opt [arg offset]]]

This method combines the two input images into a result image by
performing a pixelwise addition (image1 + image2) followed by division
through [arg scale] and addition of the [arg offset]. They default to
[const 1] and [const 0] respectively, if they are not specified.


[call [cmd ::crimp] [method {alpha blend}] [arg foreground] [arg background] [arg alpha]]
[keywords blending {alpha blending}]

This method takes two images of identical dimensions and a blending
factor [arg alpha] and returns an image which is a mix of both, with
each pixel blended per the formula

[para][image blend]
[para]

or, alternatively written

[para][image blend_alt]
[para]

This means that the [arg foreground] is returned as is for
"[arg alpha] == 255", and the [arg background] for
"[arg alpha] == 0".

I.e. the argument [arg alpha] controls the [term opacity] of the
foreground, with [const 1] and [const 0] standing for "fully opaque"
and "fully transparent", respectively.

[para]

The following combinations of fore- and background image types are
supported:

[example {
    Result = Foreground Background
    ------   ---------- ----------
    grey8    grey8      grey8
    hsv      hsv        hsv
    rgb      rgb        grey8
    rgb      rgb        rgb
    rgb      rgb        rgba
    rgba     rgba       grey8
    rgba     rgba       rgb
    rgba     rgba       rgba
    ------   ---------- ----------
}]


[call [cmd ::crimp] [method {alpha set}] [arg image] [arg mask]]
[keywords alpha {alpha channel}]

This command takes two images, the input and a [arg mask], and returns
an image as result in which the mask is the alpha channel of the
input.

The result is therefore always of type [const rgba], as the only type
supporting an alpha channel.

[para] The input image can be of type [const rgb] or [const rgba].  In
case of the latter the existing alpha channel is replaced, in case of
the former an alpha channel is added.

[para] For the mask images of type [const grey8] and [const rgba] are
accepted.  In the case of the latter the mask's alpha channel is used
as the new alpha channel, in case of the former the mask itself is
used.


[call [cmd ::crimp] [method {alpha opaque}] [arg image]]

A convenience method over [method {alpha set}], giving the [arg image]
a mask which makes it fully opaque.


[call [cmd ::crimp] [method {alpha over}] [arg foreground] [arg background]]
[keywords composition {composite blending}]

This method is similar to [method blend] above, except that there is
no global blending parameter. This information is taken from the
"alpha" channel of the [arg foreground] image instead. The blending
formula is the same, except that the alpha parameter is now a
per-pixel value, and not constant across the image.

[para]

Due to the need for an alpha channel the [arg foreground] has to be of
type [const rgba]. For the [arg background] image the types
[const rgb] and [const rgba] are supported.


[call [cmd ::crimp] [method atan2] [arg image1] [arg image2]]
[keywords hypot]

This method combines the two input images into a result image by
computing

[para][image atan2][para]

at each pixel.

[para]
The input is restricted to images of the single-channel types,
i.e. [const float] and [const "grey\{8,16,32\}"]. The result is always
of type [const float].

[para]

An application of this operation is the computation of a gradient's
direction from two images representing a gradient in X and Y directions.

For the full conversion of such cartesian gradients to a polar
representation use the [method {crimp hypot}] operation to compute the
gradient's magnitude at each pixel.


[call [cmd ::crimp] [method blank] [arg type] [arg width] [arg height] [arg value]...]

This method returns a blank image of the given image type and
dimensions.  The [arg value]s after the dimensions are the pixel
values to fill the pixels in the image's channels with, per its type.

[para] This method currently support only the types [const rgb],
[const rgba],[const fpcomplex], and [const grey8].


[call [cmd ::crimp] [method crop] [arg image] [arg ww] [arg hn] [arg we] [arg hs]]
[keywords cropping shrinking resize {edge shrinking}]

This method is the counterpart to the [method expand] family of
methods, shrinking an [arg image] by removing a border.

The size of this border is specified by the four arguments [arg ww],
[arg hn], [arg we], and [arg hs] which provide the number of pixels to
remove from the named edge. See the image below for a graphical
representation.

[para][image border][para]


[call [cmd ::crimp] [method cut] [arg image] [arg x] [arg y] [arg w] [arg h]]
[keywords {cut region} {region cut} {rectangle cut} {rectangle extraction}]
[keywords {extract rectangle} {extract region}]

This method cuts the rectangular region specified throught its [arg x]/[arg y]
position relative to the upper-left corner of the input [arg image] and its
dimensions, and returns it as its own image.

[para] Locations and dimensions reaching outside of the input image
are restricted to the interior of the input image. This means that
both location and dimensions of the result may differ from what was
specified by the arguments.

[call [cmd ::crimp] [method {decimate xy}] [arg image] [arg factor] [arg kernel]]
[call [cmd ::crimp] [method {decimate x}] [arg image] [arg factor] [arg kernel]]
[call [cmd ::crimp] [method {decimate y}] [arg image] [arg factor] [arg kernel]]

This is a convenience method combining the two steps of filtering an image
(via [method {filter convolve}]), followed by a [method downsample] step.
See the method [method interpolate] for the complementary operation.

[para] Note that while the [arg kernel] argument for [method {filter convolve}]
is expected to be the 1D form of a separable low-pass filter no checks are made.
The method simply applies both the kernel and its transposed form.

[para] The method [method {pyramid gauss}] is a user of this method.


[call [cmd ::crimp] [method degamma] [arg image] [arg y]]
[keywords {gamma correction}]

This method takes an image, runs it through an
[fun {inverse gamma correction}] with parameter [arg y], and returns
the corrected image as it result.

This is an application of method [method remap], using the mapping
returned by "[method {map degamma}] [arg y]".

This method supports all image types supported by the method
[method remap].


[call [cmd ::crimp] [method difference] [arg image1] [arg image2]]

This method combines the two input images into a result image by
taking the pixelwise absolute difference (|image1 - image2|).


[call [cmd ::crimp] [method {downsample xy}] [arg image] [arg factor]]
[call [cmd ::crimp] [method {downsample x}] [arg image] [arg factor]]
[call [cmd ::crimp] [method {downsample y}] [arg image] [arg factor]]

This method returns an image containing only every [arg factor] pixel of the
input [arg image] (in x, y, or both dimensions). The effect is that the input is
shrunken by [arg factor]. It is the complement of method [method upsample].

[para] Using the method as is is not recommended because the simple subsampling
will cause higher image frequencies to alias into the reduced spectrum, causing
artifacts to appear in the result. This is normally avoided by running a
low-pass filter over the image before doing downsampling, removing the
problematic frequencies.

[para] The [method decimate] method is a convenience method combining these
two steps into one.


[call [cmd ::crimp] [method {effect charcoal}] [arg image]]
[keywords effect charcoal]

This method applies a charcoal effect to the image, i.e. it returns a
[const grey8] image showing the input as if it had been drawn with a
charcoal pencil.


[call [cmd ::crimp] [method {effect emboss}] [arg image]]
[keywords effect emboss]

This method applies an embossing effect to the image, i.e. it returns
an image of the same type as the input showing the input as if it had
been embossed into a metal plate with a stencil of some kind.


[call [cmd ::crimp] [method {effect sharpen}] [arg image]]
[keywords effect sharpen]

This method sharpens the input image, i.e. returns an image of the
same type as the input in which the input's edges are emphasized.


[call [cmd ::crimp] [method {expand const}] [arg image] [arg ww] [arg hn] [arg we] [arg hs] [opt [arg value]...]]
[call [cmd ::crimp] [method {expand extend}] [arg image] [arg ww] [arg hn] [arg we] [arg hs]]
[call [cmd ::crimp] [method {expand mirror}] [arg image] [arg ww] [arg hn] [arg we] [arg hs]]
[call [cmd ::crimp] [method {expand replicate}] [arg image] [arg ww] [arg hn] [arg we] [arg hs]]
[call [cmd ::crimp] [method {expand wrap}] [arg image] [arg ww] [arg hn] [arg we] [arg hs]]
[keywords expansion {const expansion} {extend expansion} {mirror expansion}]
[keywords {replicate edge expansion} {wrap expansion} {cyclic wrap expansion} {toroidal wrap expansion}]

This set of methods takes an image and expands it by adding a border.

The size of this border is specified by the four arguments [arg ww],
[arg hn], [arg we], and [arg hs] which provide the number of pixels to
add at the named edge. See the image below for a graphical
representation.

[para][image border][para]

The contents of the border's pixels are specified via the border type,
the first argument after [method expand], as per the list below.

[list_begin definitions]
[def [method const]]

The additional [arg value]s specify the values to use for the color
channels of the image. Values beyond the number of channels in the
image are ignored.

Missing values are generated by replicating the last value, except for
the alpha channel, which will be set to [const 255]. If no values are
present they default to [const 0].

[def [method extend]]

This is a combination of [method mirror] and [method replicate].  The
outside pixels are the result of subtracting the outside pixel for
[method mirror] from the outside pixel for [method replicate] (and
clamping to the range [lb]0...255[rb]).

[def [method mirror]]

The outside pixels take the value of the associated inside pixels,
found by reflecting its coordinates along the relevant edges.

[def [method replicate]]

The outside pixels take the value of the associated edge pixels, i.e.
replicating them into the border.

[def [method wrap]]

The outside pixels take the value of the associated inside pixels,
found by toroidial (cyclic) wrapping its coordinates along the
relevant edges. This is also called tiling.

[list_end]


[call [cmd ::crimp] [method {fft forward}] [arg image]]
[call [cmd ::crimp] [method {fft backward}] [arg image]]
[keywords fft {fast fourier transform} {fourier transform} {inverse fourier transform}]
[keywords {transform, fast fourier} {transform, fourier} {transform, inverse fourier}]

These two methods implement 2D FFT (forward) and inverse FFT (backward).

[para]
The input is restricted to images of the single-channel types,
i.e. [const float], [const "grey\{8,16,32\}"] and [const fpcomplex].
The result is always of type [const float] for input images other than
[const fpcomplex], which returns an image of the same type instead.

[para]
The former means that it is necessary to split [const rgb],
etc. images into their channels before performing an FFT, and that
results of an inverse FFT have to be joined.

See the methods [method split] and [method join] for the relevant
operations and their syntax.

[para]
The latter means that a separate invokation of method
[method {convert 2grey8}] is required when reconstructing an image
by inverting its FFT.


[call [cmd ::crimp] [method {filter ahe}] [arg image] [opt "[option -border] [arg spec]"] [opt [arg radius]]]

This method performs adaptive histogram equalization to enhance the
contrast of the input image. Each pixel undergoes regular histogram
equalization, with the histogram computed from the pixels in the
[var N]x[var N] square centered on it, where
"[var N] = 2*[var radius]+1".

[para]
The default radius is [const 3], for a 7x7 square.


[call [cmd ::crimp] [method {filter convolve}] [arg image] [opt "[option -border] [arg spec]"] [arg kernel]...]
[keywords {convolution filter} filter]

This method runs the series of filters specified by the convolution
[arg kernel]s over the input and returns the filtered result. See the
method [method kernel] and its sub-methods for commands to create and
manipulate suitable kernels.

[para] The border specification determines how the input image is
expanded (see method [method expand]) to compensate for the shrinkage
introduced by the filter itself. The [arg spec] argument is a list
containing the name of the sub-method of [method expand] to use, plus
any additional arguments this method may need, except for the size of
the expansion.

[para] By default a black frame is used as the border, i.e.
"[arg spec] == {const 0}".


[call [cmd ::crimp] [method {filter gauss discrete}] [arg image] [arg sigma] [opt [arg r]]]
[call [cmd ::crimp] [method {filter gauss sampled}] [arg image] [arg sigma] [opt [arg r]]]

These methods apply a discrete or sampled gaussian blur with
parameters [arg sigma] and kernel [arg r]adius to the [arg image]. If
the radius is not specified it defaults to the smallest integer
greater than "3*[arg sigma]".


[call [cmd ::crimp] [method {filter mean}] [arg image] [opt "[option -border] [arg spec]"] [opt [arg radius]]]
[keywords {mean filter} filter]

This method applies a mean filter with [arg radius] to the
image. I.e. each pixel of the result is the mean value of all pixels
in the [var N]x[var N] square centered on it, where
"[var N] = 2*[var radius]+1".

[para]
The default radius is [const 3], for a 7x7 square.

[para]
[emph NOTE]. As the mean is known to be in the range defined by the
channel this method automatically converts float results back to the
channel type. This introduces rounding / quantization errors. As a
result of this price being paid the method is able to handle
multi-channel images, by automatically splitting, processing, and
rejoining its channels.

[para]
The method [method {filter stddev}] on the other makes the reverse
tradeoff, keeping precision, but unable to handle multi-channel
images.

[call [cmd ::crimp] [method {filter rank}] [arg image] [opt "[option -border] [arg spec]"] [opt "[arg radius] [opt [arg percentile]]"]]
[keywords filter {rank-order filter} {max-filter} {min-filter} {median-filter}]

This method runs a rank-filter over the input and returns the filtered
result.

[para] The border specification determines how the input image is
expanded (see method [method expand]) to compensate for the shrinkage
introduced by the filter itself. The [arg spec] argument is a list
containing the name of the sub-method of [method expand] to use, plus
any additional arguments this method may need, except for the size of
the expansion.

[para] By default a black frame is used as the border, i.e.
"[arg spec] == {const 0}".

[para] The [arg radius] specifies the (square) region around each
pixel which is taken into account by the filter, with the pixel value
selected according to the [arg percentile]. The filter region of each
pixel is a square of dimensions "2*[arg radius]+1", centered around
the pixel.

[para] These two values default to [const 3] and [const 50], respectively.

[para] Typical applications of rank-filters are min-, max-, and
median-filters, for percentiles 0, 100, and 50, respectively.

[para] Note that percentiles outside of the range [const 0]...[const 100]
make no sense and are clamped to this range.


[call [cmd ::crimp] [method {filter stddev}] [arg image] [opt "[option -border] [arg spec]"] [opt [arg radius]]]
[keywords {standard deviation filter} filter]

This method applies a stand deviation filter with [arg radius] to the
image. I.e. each pixel of the result is the standard deviation of all
pixel values in the [var N]x[var N] square centered on it, where

"[var N] = 2*[var radius]+1".

[para]
The default radius is [const 3], for a 7x7 square.

[para]

[emph NOTE]. As the standard deviation is often quite small and its
precision important the result of this method is always an image of
type [const float]. Because of this this method is unable to handle
multi-channel images as the results of processing their channels
cannot be joined back together for the proper type.

[para]
The method [method {filter mean}] on the other hand makes the reverse
tradeoff, handling multi-channel images, but dropping precision.


[call [cmd ::crimp] [method {filter sobel x}] [arg image]]
[call [cmd ::crimp] [method {filter sobel y}] [arg image]]
[call [cmd ::crimp] [method {filter scharr x}] [arg image]]
[call [cmd ::crimp] [method {filter scharr y}] [arg image]]
[call [cmd ::crimp] [method {filter prewitt x}] [arg image]]
[call [cmd ::crimp] [method {filter prewitt y}] [arg image]]
[call [cmd ::crimp] [method {filter roberts x}] [arg image]]
[call [cmd ::crimp] [method {filter roberts y}] [arg image]]
[call [cmd ::crimp] [method {filter canny sobel}] [arg image]]
[call [cmd ::crimp] [method {filter canny deriche}] [arg image]]
[keywords filter sobel scharr prewitt edge-detection roberts canny gradient]

These methods are convenience methods implementing a number of standard
convolution filters using for edge detection and calculation of image
gradients.

[para]
See the [method {crimp gradient}] methods for users of these filters.

[para]
Also note that the [method x] methods emphasize gradient in the horizontal
direction, and thus highlight [emph vertical] lines, and vice versa for
[method y].

[call [cmd ::crimp] [method {filter wiener}] [arg image] [arg radius]]

This method filters an image that has been degraded by constant power additive
noise. It uses a pixelwise adaptive Filter method based on statistics estimated
from a local neighborhood of each pixel. The default value for radius is 2

[call [cmd ::crimp] [method gamma] [arg image] [arg y]]

This method takes an image, runs it through a [fun {gamma correction}]
with parameter [arg y], and returns the corrected image as it result.

This is an application of method [method remap], using the mapping
returned by "[method {map gamma}] [arg y]".

This method supports all image types supported by the method
[method remap].


[call [cmd ::crimp] [method {gradient sobel}] [arg image]]
[call [cmd ::crimp] [method {gradient scharr}] [arg image]]
[call [cmd ::crimp] [method {gradient prewitt}] [arg image]]
[call [cmd ::crimp] [method {gradient roberts}] [arg image]]
[keywords sobel scharr prewitt edge-detection gradient roberts]

These methods generate two gradient images for the input image, in the
X- and Y-directions, using different semi-standard filters. I.e. the
result is a cartesian representation of the gradients in the input.
The result is a 2-element list containing the X- and Y-gradient
images, in this order.


[call [cmd ::crimp] [method {gradient polar}] [arg cgradient]]

This method takes a gradient in cartesian representation (as
returned by the above methods) and converts it to polar
representation, i.e. magnitude and angle. The result of the method
is a 2-element list containing two [const float] images, the
magnitude and angle, in this order. The angle is represented
in degrees running from 0 to 360.


[call [cmd ::crimp] [method {gradient visual}] [arg pgradient]]

This method takes a gradient in polar representation (as
returned by method [method {gradient polar}]) and converts it
into a color image ([const rgb]) visualizing the gradient.

[para]
The visualization is easier to understand in HSV space tough,
with the angle mapped to Hue, i.e. color, magnitude to Value,
and Saturation simply at full.


[call [cmd ::crimp] [method hypot] [arg image1] [arg image2]]
[keywords hypot]

This method combines the two input images into a result image by
computing

[para][image hypot][para]

at each pixel.

[para]
The input is restricted to images of the single-channel types,
i.e. [const float] and [const "grey\{8,16,32\}"]. The result is always
of type [const float].

[para]

An application of this operation is the computation of the gradient
magnitude from two images representing a gradient in X and Y directions.

For the full conversion of such cartesian gradients to a polar
representation use the [method {crimp atan2}] operation to compute the
gradient's direction at each pixel.


[call [cmd ::crimp] [method integrate] [arg image]]
[keywords {integral image} {summed area table}]

This method takes any single-channel image, i.e. of types
[const float] and [const "grey\{8,16,32\}"], and returns its integral,
i.e. a summed area table. The type of the result is always of type
[const float].


[call [cmd ::crimp] [method {interpolate xy}] [arg image] [arg factor] [arg kernel]]
[call [cmd ::crimp] [method {interpolate x}] [arg image] [arg factor] [arg kernel]]
[call [cmd ::crimp] [method {interpolate y}] [arg image] [arg factor] [arg kernel]]

This is a convenience method combining the two steps of an [method upsample],
followed by a filter step (via [method {filter convolve}]). See the method
[method decimate] for the complementary operation.

[para] Note that while the [arg kernel] argument for [method {filter convolve}]
is expected to be 1D form of a separable low-pass filter no checks are made.
The method simply applies both the kernel and its transposed form.

[para] The methods [method {pyramid gauss}] and [method {pyramid laplace}] are
users of this method.


[call [cmd ::crimp] [method invert] [arg image]]
[keywords inversion]

This method takes an image, runs it through the [fun inverse]
function, and returns the modified image as it result.

This is an application of method [method remap], using the mapping
returned by "[method {map inverse}]".

This method supports all image types supported by the method
[method remap].


[call [cmd ::crimp] [method logpolar] [arg image] [arg rwidth] [arg rheight] [opt [arg xcenter]] [opt [arg ycenter]] [opt [arg corners]]]
[keywords {log-polar transformation} {transformation, log-polar}]

This method takes an [arg image] and returns the log-polar
transformation of the input. This means that in the result each pixel
is described by an angle and the logarithm of the distance to a chosen
point.

[para] The angle is plotted on the x-axis of the result, as fraction
or multiples of degrees, depending on the chosen resolution
[arg rwidth].  A value of [const 360], for example, provides a
resolution of 1 degree in the result. The angle is counted from 0 due
right (the positive x-axis of the input) counterclockwise.

[para] The log of the distance is plotted on the y-axis of the result,
with a precision of [arg rheight].

[para] The [term {center point}] is specified as offset [arg xcenter],
[arg ycenter] from the center of the input image. I.e. the defaults of
(0, 0) for both, when not specified, refer to the center of the input.

[para] The optional flag [arg corners] specifies whether to include
the corners of the input in the result ([const true]), or not
([const false]). This defaults to [const true], including the corners.


[call [cmd ::crimp] [method matrix] [arg image] [arg matrix]]
[keywords matrix {projective transform} transform {affine transform}]

This method takes an image and a 3x3 matrix specified as nested Tcl
list (row major order), applies the projective transform represented
by the matrix to the image and returns the transformed image as its
result.

[para]

Notes: It is currently unclear how the output pixel is computed
(nearest neighbour, bilinear, etc.) (code inherited from AMG). This
requires more reading, and teasing things apart. The transfomred image
is clipped to the dimensions of the input image, i.e. pixels from the
input may be lost, and pixels in the output may be unset as their
input would come from outside of the input.

[para]

The operation supports only images of type [const rgba], and returns
images of the same type.


[call [cmd ::crimp] [method max] [arg image1] [arg image2]]
[keywords max]

This method combines the two input images into a result image by
taking the pixelwise maximum.


[call [cmd ::crimp] [method min] [arg image1] [arg image2]]
[keywords min]

This method combines the two input images into a result image by
taking the pixelwise minimum.


[call [cmd ::crimp] [method {montage horizontal}] [opt "[option -align] [const top]|[const center]|[const bottom]"] [opt "[option -border] [arg spec]"] [arg image]...]
[call [cmd ::crimp] [method {montage vertical}]   [opt "[option -align] [const left]|[const middle]|[const right]"] [opt "[option -border] [arg spec]"] [arg image]...]
[keywords montage]

The result of these methods is an image where the input images have
been placed adjacent to each from left to right (horizontal), or top
to bottom (vertical). The input images have to have the same type.

[para]
There is no need however for them to have the same height, or width,
respectively. When images of different height (width) are used the
command will expand them to their common height (width), which is the
maximum of all heights (widths). The expansion process is further
governed by the values of the [option -align] and [option -border]
options, with the latter specifying the form of the expansion (see
method [method expand] for details), and the first specifying how the
image is aligned within the expanded space.

[para]
The [arg spec] argument of [option -border] is a list containing the
name of the sub-method of [method expand] to use, plus any additional
arguments this method may need, except for the size of the expansion.

[para]
The default values for [option -align] are [const center] and
[const middle], centering the image in the space. The default for the
[option -border] is a black frame, i.e. "[arg spec] == {const 0}".


[call [cmd ::crimp] [method {morph dilate}] [arg image]]
[call [cmd ::crimp] [method {morph erode}] [arg image]]
[keywords morphology erosion dilation]

These two methods implement the basic set of morphology operations,
[term erosion], and [term dilation] using a flat 3x3 brick as their
structuring element. For grayscale, which we have here, these are,
mathematically, max and min rank-order filters, i.e.

[example {
    dilate = filter rank 1 99.99 (max)
    erode  = filter rank 1  0.00 (min)
}]

The above definitions assume that background is [const black], and
foreground/object anything but black, usually [const white]. Then it
is easy to see that [cmd dilate] expands the foreground/white, and
erode expands background/black.


[call [cmd ::crimp] [method {morph close}] [arg image]]
[call [cmd ::crimp] [method {morph open}] [arg image]]
[keywords morphology opening closing]

These two methods add to the basic set of morphology operations,
[term opening] and [term closing]. In terms of erosion and dilation:

[example {
    close = erode o dilate
    open  = dilate o erode
}]


[call [cmd ::crimp] [method {morph gradient}] [arg image]]
[keywords morphology gradient]

The morphological [term gradient] is defined as

[example {
    [dilate $image] - [erode $image]
}]

This can also be expressed as the sum of the external and internal
gradients, see below.


[call [cmd ::crimp] [method {morph igradient}] [arg image]]
[keywords morphology {internal gradient}]

The morphological [term {internal gradient}] is defined as

[example {
    $image - [erode image]
}]


[call [cmd ::crimp] [method {morph egradient}] [arg image]]
[keywords morphology {external gradient}]

The morphological [term {external gradient}] is defined as

[example {
    [dilate $image] - $image
}]


[call [cmd ::crimp] [method {morph tophatw}] [arg image]]
[keywords morphology tophat {white tophat}]

The [term {white tophat}] transformation is defined as

[example {
    $image - [open $image]
}]

See [sectref References] 3 to 5 (page 32). This is a greyscale morphology
operation which does not properly apply to binary images.


[call [cmd ::crimp] [method {morph tophatb}] [arg image]]
[keywords morphology tophat {black tophat}]

The [term {black tophat}] transformation is defined as

[example {
    [close $image] - $image
}]

See [sectref References] 3 to 5 (page 33). This is a greyscale morphology
operation which does not properly apply to binary images.


[call [cmd ::crimp] [method {morph toggle}] [arg image]]
[keywords morphology {toggle map}]

The [term {toggle map}] is defined as

[example {
    0.5 * ([erode $image] + [dilate $image])
}]

See [sectref References] 5, pages 34 and 35. This is a greyscale
morphology operation to sharpen edges.


[call [cmd ::crimp] [method multiply] [arg image1] [arg image2]]

This method combines the two input images into a result image by
performing a pixelwise multiplication. Note that the result of each
multiplication is divided by [const 255] to scale it back into the
range [lb]0...255[rb].

[para]
[call [cmd ::crimp] [method {noise random}] [arg w] [arg h]]

This method creates an image of type [const float] with the specified
dimensions. The pixels are set to random values in the interval
[lb]0...1[rb].

[call [cmd ::crimp] [method {noise saltpepper}] [arg image] [opt [arg density]]]
[call [cmd ::crimp] [method {noise gaussian}] [arg image] [opt [arg mean]] [opt [arg variance]]]
[call [cmd ::crimp] [method {noise speckle}] [arg image] [opt [arg variance]]]

These methods add noises of different types to the given image.

[para] [method saltpepper] adds salt and pepper noise of the specified
[arg density]. This density must be in the range [lb]0...1[rb]. If not
specified it defaults to [const 0.05].

[para] [method gaussian] adds gaussian noise of the specified mean and
variance to the image. If not specified the mean and variance default
to [const 0] and [const 0.05], respectively. Both must be in the range
[lb]0...1[rb].

[para] [method speckle] adds multiplicative noise of the specified
variance to the image. This variance must be in the range
[lb]0...1[rb]. If not specified it defaults to [const 0.05].

[call [cmd ::crimp] [method psychedelia] [arg width] [arg height] [arg frames]]

This method creates an [const rgba] image of the specified dimensions
according to an algorithm devised by Andrew M. Goth. The [arg frames]
argument specifies how many images are in the series.

[para][emph Attention:] This method keeps internal global state,
ensuring that each call returns a slightly different image. Showing a
series of such images as animation provides an effect similar to a
lava lamp or hallucination.


[call [cmd ::crimp] [method {pyramid run}] [arg image] [arg steps] [arg stepcmd]]

This method provides the core functionality for the generation of image
pyramids. The command prefix [arg stepcmd] is run [arg steps] times,
first on the [arg image], then on the result of the previous step.

[para] The assumed signature of [arg stepcmd] is
[list_begin definitions]
[call [cmd <stepcmd>] [arg image]]

which is expected to return a list of two elements. The first element
([term result]) is added to the pyramid in building, whereas the second
element ([term iter]) is used in the next step as the input of the step
command.

[list_end]

[para] The final result of the method is a list containing the input
[arg image] as its first element, followed by the results of the step
function, followed by the [term iter] element returned by the last step,
"[arg steps]+2" images in total.

[para][image pyramid]


[call [cmd ::crimp] [method {pyramid gauss}] [arg image] [arg steps]]

This method generates a gaussian image pyramid [arg steps] levels deep and
returns it as a list of images.

[para] The first image in the result is the input, followed by [arg steps]
successively smaller images, each [method decimate]d by a factor two
compared to its predecessor, for a total length of "[arg steps]+1" images.

[para] The convolution part of the decimation uses

[example { 1/16 [1 4 6 4 1] }]

as its kernel.

[para][image pyramid_gauss]


[call [cmd ::crimp] [method {pyramid laplace}] [arg image] [arg steps]]

This method generates a laplacian image pyramid [arg steps] levels deep and
returns it as a list of images.

[para] The first image in the result is the input, followed by [arg steps]
band pass images (differences of gaussians). The first band pass has the same
size as the input image, and each successor is [method decimate]d by two. This
is followed by one more image, the gaussian of the last step. This image is
decimated by two compared to the preceding bandpass image. In total the result
contains "[arg steps]+2" images.

[para] The convolution part of the decimation uses

[example { 1/16 [1 4 6 4 1] }]

as its kernel. The internal interpolation used to generate the band pass
images (resynthesis) doubles the weights of this kernel for its convolution
step.

[para][image pyramid_laplace]


[call [cmd ::crimp] [method remap] [arg image] [arg map]...]
[keywords {pixel mapping} remapping]

[comment {one of three core -- remap-conditional, and recolor by 3x3 matrix}]

This method is the core primitive for the per-pixel transformation of
images, with each pixel (and channels within, if any) handled
independently of all others.

Applications of this operator provided by this package are (inverse)
gamma correction, pixel inversion, and solarization. Many more are
possible, especially when considering other colorspaces like
HSV. There, for example, it is possible change the saturation of
pixels, or shift the hue in arbitrary manner.

[para]

Beyond the input [arg image] to transform one or more [term maps] are
specified which define how each pixel value in the input is mapped to
a pixel value in the output. The command will accept at most that many
maps as the input image has channels.  If there are less maps than
channel the last map specified is replicated to cover the other
channels. An exception of this is the handling of the alpha channel,
should the input image have such. There a missing map is handle as
[fun identity], i.e. the channel copied as is, without changes.

[para]

The maps are not Tcl data structures, but images themselves.  They
have to be of type [const grey8], and be of dimension 256x1 (width by
height).

[para]

The [method {crimp map ...}] methods are sources for a number of
predefined maps, whereas the [method mapof] method allows the
construction of maps from Tcl data structures, namely lists of values.

[para] This method supports all image types with one or more
single-byte channels, i.e. all but [const grey16], [const grey32],
[const float], and [const bw].

[call [cmd ::crimp] [method matchsize] [arg image1] [arg image2]]

This method takes two images, forces them to be of the same size by
expanding the smaller dimensions with black pixels, and then returns a
list of the expanded images. The images in the result are in the same
order as as arguments.

[call [cmd ::crimp] [method screen] [arg image1] [arg image2]]

This method combines the two input images by inverting the
multiplication of the inverted input images. I.e.

[para][image screen][para]

[call [cmd ::crimp] [method solarize] [arg image] [arg threshold]]
[keywords solarization {sabattier effect}]

This method takes an image, runs it through the [fun solarize]
function with parameter [arg threshold], and returns the modified
image as it result. This is also known as the [term {sabattier effect}].

This is an application of method [method remap], using the mapping
returned by "[method {map solarize}] [arg threshold]".

This method supports all image types supported by the method
[method remap].

[call [cmd ::crimp] [method square] [arg image]]

This is a convenience method equivalent to
"[cmd {crimp multiply}] [arg image] [arg image]".


[call [cmd ::crimp] [method subtract] [arg image1] [arg image2] [opt [arg scale]] [opt [arg offset]]]

This method combines the two input images into a result image by
performing a pixelwise subtraction (image1 - image2) followed by
division through [arg scale] and addition of the [arg offset]. They
default to [const 1] and [const 0] respectively, if they are not
specified.


[call [cmd ::crimp] [method {threshold global above}] [arg image] [arg threshold]]
[keywords thresholding binarization]

This method takes an image, runs it through the [fun {threshold above}]
function with parameter [arg threshold], and returns the modified
image as it result. As the result only contains black and white,
i.e. 2 colors, this process is also called [term binarization] or
foreground/background segmentation.

This is an application of method [method remap], using the mapping
returned by "[method {map threshold above}] [arg threshold]".

This method supports all image types supported by the method
[method remap].


[call [cmd ::crimp] [method {threshold global below}] [arg image] [arg threshold]]
[keywords thresholding binarization]

This method takes an image, runs it through the [fun {threshold below}]
function with parameter [arg threshold], and returns the modified
image as it result. As the result only contains black and white,
i.e. 2 colors, this process is also called [term binarization], or
foreground/background segmentation.

This is an application of method [method remap], using the mapping
returned by "[method {map threshold below}] [arg threshold]".

This method supports all image types supported by the method
[method remap].


[call [cmd ::crimp] [method {threshold global inside}] [arg image] [arg min] [arg max]]
[keywords thresholding binarization]

This method takes an image, runs it through the [fun {threshold inside}]
function with parameters [arg min] and [arg max], and returns the
modified image as it result. As the result only contains black and
white, i.e. 2 colors, this process is also called [term binarization]
or foreground/background segmentation.

This is an application of method [method remap], using the mapping
returned by "[method {map threshold above}] [arg threshold]".

This method supports all image types supported by the method
[method remap].


[call [cmd ::crimp] [method {threshold global outside}] [arg image] [arg min] [arg max]]
[keywords thresholding binarization]

This method takes an image, runs it through the [fun {threshold outside}]
function with parameters [arg min] and [arg max], and returns the
modified image as it result. As the result only contains black and
white, i.e. 2 colors, this process is also called [term binarization],
or foreground/background segmentation.

This is an application of method [method remap], using the mapping
returned by "[method {map threshold below}] [arg threshold]".

This method supports all image types supported by the method
[method remap].


[call [cmd ::crimp] [method {threshold global middle}] [arg image]]
[call [cmd ::crimp] [method {threshold global mean}] [arg image]]
[call [cmd ::crimp] [method {threshold global median}] [arg image]]
[call [cmd ::crimp] [method {threshold global otsu}] [arg image]]
[keywords thresholding binarization]

These four methods are convenience methods layered on top of
[cmd {crimp threshold global below}]. They compute the value(s) to
perform the thresholding with from the global statistics of the input
image, with the element taken named by the method. For reference see
the documentation of method [cmd {crimp statistics ...}]. Note that
they treat each color channel in the image separately.


[call [cmd ::crimp] [method {threshold local}] [arg image] [arg threshold]...]
[keywords thresholding binarization]

This method takes an [arg image] and one or more [arg threshold] maps
and returns an image where all pixels of the input which were larger
or equal to the corresponding pixel in the map are set to black. All
other pixels are set to white. Each map is applied to one color
channel of the input image. If there are too many maps the remainder
is ignored. If there are not enough maps the last map is replicated.

[para] This is the core for all methods of non-global
[term binarization], i.e. foreground/background segmentation. Their
differences are just in the calculation of the maps.

[para] This method supports all image types with one or more
single-byte channels, i.e. all but [const grey16], [const grey32], and
[const bw].


[call [cmd ::crimp] [method {upsample xy}] [arg image] [arg factor]]
[call [cmd ::crimp] [method {upsample x}] [arg image] [arg factor]]
[call [cmd ::crimp] [method {upsample y}] [arg image] [arg factor]]

This method returns an image inserting [arg factor] black pixels between
each pixel of the input [arg image] (in x, y, or both dimensions). The effect is
that the input is expanded by [arg factor]. It is the complement of
method [method downsample].

[para] Using the method as is is not recommended because this simple upsampling
will cause copies of the image to appear at the higher image frequencies in the
expanded spectrum. This is normally avoided by running a low-pass filter over
the image after the upsampling, removing the problematic copies.

[para] The [method interpolate] method is a convenience method combining these
two steps into one.


[call [cmd ::crimp] [method wavy] [arg image] [arg offset] [arg adj1] [arg adjb]]

This method processes the input [arg image] according to an algorithm
devised by Andrew M. Goth, according to the three parameters
[arg offset], [arg adj1], and [arg adjb], and returns the modified
image as its result.

[para]

The operation supports only images of type [const rgba], and returns
images of the same type.


[call [cmd ::crimp] [method {flip horizontal}] [arg image]]
[call [cmd ::crimp] [method {flip transpose}] [arg image]]
[call [cmd ::crimp] [method {flip transverse}] [arg image]]
[call [cmd ::crimp] [method {flip vertical}] [arg image]]
[keywords flip transform warp geometry]

This set of methods performs mirroring along the horizontal, vertical
and diagonal axes of the input [arg image], returning the mirrored
image as their output.  Transpose mirrors along the main diagonal,
transverse along the secondary diagonal.  These two methods also
exchange width and height of the image in the output.

[para] The methods currently support the image types [const rgb],
[const rgba], [const hsv], and [const grey8].


[call [cmd ::crimp] [method resize] [opt "[option -interpolate] [const nneighbour]|[const bilinear]|[const bicubic]"] [arg image] [arg w] [arg h]]
[keywords resize transform warp geometry]

This method takes the input [arg image] and resizes it to the
specified width [arg w] and height [arg h].

In constrast to [method cut] this is not done by taking part of the
image in the specified size, but by scaling it up or down as
needed. In other words, this method is a degenerate case of a
projective transform as created by the [method transform] methods and
used by method [method {warp projective}] (see below).

[para] Like the aforementioned general method this method supports all
the possible interpolation types, i.e. nearest neighbour, bilinear,
and bicubic. By default [const bilinear] interpolation is used, as a
compromise between accuracy and speed.


[call [cmd ::crimp] [method {rotate cw}]  [arg image]]
[call [cmd ::crimp] [method {rotate ccw}] [arg image]]
[keywords rotation clockwise counter-clockwise transform warp geometry]

This set of methods rotates the image in steps of 90 degrees, either
clockwise and counter to it.

[call [cmd ::crimp] [method {rotate half}] [arg image]]
[keywords rotation clockwise counter-clockwise transform warp geometry]

This methods rotates the image a half-turn, i.e. 180 degrees.


[call [cmd ::crimp] [method {warp field}] [opt "[option -interpolate] [const nneighbour]|[const bilinear]|[const bicubic]"] [arg image] [arg xvec] [arg yvec]]
[keywords transform warp geometry vector-field]

This method takes an input image and two images the size of the
expected result which provide for each pixel in the result the
coordinates to sample in the input to determine the result's color.

[para] This allows the specification of any possible geometric
transformation and warping, going beyond even projective
transformations.

[para] The two images providing the coordinate information have to be
of the same size, which is also the size of the returned result. The
type of the result is however specified through the type of the input
image.

[para] The method supports all the possible interpolation types,
i.e. nearest neighbour, bilinear, and bicubic.
By default [const bilinear] interpolation is used, as a compromise
between accuracy and speed.


[call [cmd ::crimp] [method {warp projective}] [opt "[option -interpolate] [const nneighbour]|[const bilinear]|[const bicubic]"] [arg image] [arg transform]]
[keywords transform warp geometry projective perspective affine translate scale rotate rescale]

This method accepts a general projective [arg transform] as created by
the [method transform] methods, applies it to the input [arg image]
and returns the projected result.

[para] Like the [method resize] method above this method supports all
the possible interpolation types, i.e. nearest neighbour, bilinear,
and bicubic. By default [const bilinear] interpolation is used, as a
compromise between accuracy and speed.

[para] [emph Note] that the returned result image is made as large as
necessary to contain the whole of the projected input. Depending on
the transformation this means that parts of the result can be black,
coming from outside of the boundaries of the input. Further, the
origin point of the result may conceptually be inside or outside of
the result instead of at the top left corner, because of pixels in the
input getting projected to negative coordinates. To handle this
situation the result will contain the physical coordinates of the
conceptual origin point in its meta data, under the hierarchical key
[const {crimp origin}].

[call [cmd ::crimp] [method window] [arg image]]
[keywords windowing]

This method takes an image, applies a windowing function to it that
fades the pixels to black towards the edges, and returns the windowed
result.

[list_end]


[subsection Converters]
[list_begin definitions]
[call [cmd ::crimp] [method {convert 2grey32}] [arg image]]
[call [cmd ::crimp] [method {convert 2grey16}] [arg image]]
[call [cmd ::crimp] [method {convert 2grey8}] [arg image]]
[call [cmd ::crimp] [method {convert 2float}] [arg image]]
[call [cmd ::crimp] [method {convert 2complex}] [arg image]]
[call [cmd ::crimp] [method {convert 2hsv}] [arg image]]
[call [cmd ::crimp] [method {convert 2rgba}] [arg image]]
[call [cmd ::crimp] [method {convert 2rgb}] [arg image]]
[call [cmd ::crimp] [method {convert 2rgb}] [arg image]]

This set of methods all convert their input [arg image] to the
specified type and returns it as their result. All converters accept
an image of the destination type as input and will pass it through
unchanged.

[para]

The converters returning a [const grey8] image support [const float],
[const rgb] and [const rgba] as their input. For multi-channel input
they use the ITU-R 601-2 luma transform to merge the color channels.

[para]

The converters returning a [const grey16], [const grey32] image
support only [const float] as their input.

[para]

The converters to HSV support [const rgb] and [const rgba] as their
input as well.

[para]

The conversion to [const rgba] accepts only [const hsv] as input,
adding a blank (fully opaque) alpha channel. For more control over the
contents of an image's alpha channel see the methods [method setalpha]
and [method {join rgba}].

[para]

The conversion to [const rgb] accepts both [const rgba] and
[const hsv] images as input.

[para]

The conversion to [const float] supports only [const fpcomplex] as
input. It simply strips the imaginary part of the input.

[para]

The conversion to [const fpcomplex] accepts [const float],
[const grey8], [const grey16], and [const grey32] as input, and adds a
constant [const 0] imaginary part.

[call [cmd ::crimp] [method {complex magnitude}] [arg image]]

This method takes an image of type [const fpcomplex] as input and
returns an image of type [const float] containing the pixel-wise
magnitude of the input.

[call [cmd ::crimp] [method {complex 2complex}] [arg image]]

This method takes an image of type [const float] as input and returns
an image of type [const fpcomplex] with each pixel's real part
containing the input, and the imaginary part set to [const 0].

[para] This method is an alias for [cmd {crimp convert 2complex}].

[call [cmd ::crimp] [method {complex imaginary}] [arg image]]

This method takes an image of type [const fpcomplex] as input and
returns an image of type [const float] containing the pixel-wise
[const imaginary] part of the input.

[call [cmd ::crimp] [method {complex real}] [arg image]]

This method takes an image of type [const fpcomplex] as input and
returns an image of type [const float] containing the pixel-wise
[const real] part of the input.

[para] This method is an alias for [cmd {crimp convert 2float}] as
applied to images of type [const fpcomplex].

[call [cmd ::crimp] [method {complex conjugate}] [arg image]]

This method takes an image of type [const fpcomplex] as input and
returns an image of the same type containing the pixel-wise complex
conjugate of the input.

[call [cmd ::crimp] [method {join 2hsv}] [arg hueImage] [arg satImage] [arg valImage]]
[call [cmd ::crimp] [method {join 2rgba}] [arg redImage] [arg greenImage] [arg blueImage] [arg alphaImage]]
[call [cmd ::crimp] [method {join 2rgb}] [arg redImage] [arg greenImage] [arg blueImage]]
[call [cmd ::crimp] [method {join 2complex}] [arg realImage] [arg imaginaryImage]]
[call [cmd ::crimp] [method {join 2grey16}] [arg msbImage] [arg lsbImage]]
[call [cmd ::crimp] [method {join 2grey32}] [arg mmsbImage] [arg lmsbImage] [arg mlsbImage] [arg llsbImage]]

This set of methods is the complement of method [method split]. Each
takes a set of [const grey8] images and fuses them together into an
image of the given type, with each input image becoming one channel of
the fusing result, which is returned as the result of the command. All
input images have to have the same dimensions.

[para] The command [method {join 2complex}] is an exception regarding
the input. It accepts images of type [const float], not [const grey8].

[para] The commands [method {join 2grey*}] are slightly different
too. As the result has only one color channel, what is to join ? Their
pixels are multi-byte, 2 and 4 respectively. The input images are not
color channel, but become the msb and lsb of the respective pixel in
the result.

[call [cmd ::crimp] [method split] [arg image]]

This method takes an image of one of the multi-channel types, i.e.
[const rgb], [const rgba], [const hsv], and [const fpcomplex] and
returns a list of [const grey8] images, each of which contains the
contents of one of the channels found in the input image.

[para] The input image type [const fpcomplex] is an exception
regarding the output. It returns images of type [const float], not
[const grey8].

[para] The method is also able to take an image of one of the
single-channel multi-byte types, i.e.  [const grey16], and
[const grey32] and returns a list of 2 (4) [const grey8] images, each
of which contains one of the bytes a pixel is made out of, in msb to
lsb order.

[para] The channel images in the result are provided in the same order
as they are accepted by the complementary [method join] method, see
above.

[list_end]


[subsection {I/O commands}]
[list_begin definitions]
[call [cmd ::crimp] [method {read pgm}] [arg string]]

This method returns an image of type [const grey8] containing the data
of the portable grey map (PGM) stored in the [arg string]. The method
recognizes images in both plain and raw sub-formats.


[call [cmd ::crimp] [method {read ppm}] [arg string]]

This method returns an image of type [const rgb] containing the data
of the portable pix map (PPM) stored in the [arg string]. The method
recognizes images in both plain and raw sub-formats.


[call [cmd ::crimp] [method {read strimj}] [arg string] [opt [arg colormap]]]

This method returns an image of type [const rgba] containing the data
of the [term strimj] (string image) (See [uri http://wiki.tcl.tk/1846])
stored in the [arg string].

[para] The caller can override the standard mapping from pixel characters
to colors by specifying a [arg colormap]. This argument is interpreted as
dictionary mapping characters to triples of integers in the range
[lb]0...255[rb], specifying the red, green, and blue intensities.

[para] An example of a strimj is:
[example {
@...@.......@.@......
@...@.......@.@......
@...@..@@@..@.@..@@@.
@@@@@.@...@.@.@.@...@
@...@.@@@@@.@.@.@...@
@...@.@.....@.@.@...@
@...@.@...@.@.@.@...@
@...@..@@@..@.@..@@@.
}]

[list_end]


[subsection Support]
[list_begin definitions]

[call [cmd ::crimp] [method {gradient grey8}] [arg from] [arg to] [arg size]]
[call [cmd ::crimp] [method {gradient rgb}] [arg from] [arg to] [arg size]]
[call [cmd ::crimp] [method {gradient rgba}] [arg from] [arg to] [arg size]]
[call [cmd ::crimp] [method {gradient hsv}] [arg from] [arg to] [arg size]]

This set of methods takes two "color" (pixel value) arguments and
returns an image of height 1 and width [arg size] containing a
gradient interpolating between these two colors, with [arg from] in
the pixel at the left (x == 0) and [arg to] at the right
(x == [arg size]-1).

[para] [arg size] has to be greater than or equal to [const 2]. An
error is thrown if that restriction is not met.

[para] The resulting image has the type indicated in the method name.
This also specifies what is expected as the contents of the arguments
[arg from] and [arg to]. For [method grey8] these are simple pixel
values in the range 0...255 whereas for the types [method rgb] and
[method hsv] the arguments are triples (3-element lists) specifying
the R, G, and B (and H, S, and V respectively) values.

[call [cmd ::crimp] [method {register translation}] [arg needle] [arg haystack]]

This method takes two images which are translated copies of each other
and returns a dictonary containing the two keys [const Xshift] and
[const Yshift], which together specify the translation to apply to the
[arg needle] to place it in the [arg haystack].

[call [cmd ::crimp] [method {kernel make}] [arg matrix] [opt [arg scale]] [opt [arg offset]]]

This method takes a [arg matrix] of weights and an optional
[arg scale] factor and returns a structure containing the associated
convolution kernel, ready for use by method [method {filter convolve}].

[para] If [arg scale] is left unspecified it defaults to the sum of
all weights in the matrix.

[para] If [arg offset] is left unspecified it defaults to 128 if the
sum of weights is 0, and 0 else. In effect zero-sum kernels, like the
basic edge-detectors, are shifted so that results in the range
-128..127 correspond to 0..255.

[para] The [arg matrix] has the same general format as the pixel
matrix for method [method {read tcl grey8}], i.e. a list of lists
(rows) of values, and is treated in the same way, i.e. the number of
columns is the maxium length over the row lists, and shorter lists are
padded with [const 128]. The values are expected to be integer numbers
in the range -128..127.


[call [cmd ::crimp] [method {kernel fpmake}] [arg matrix] [opt [arg offset]]]

This method is like [method {kernel make}] except that the generated
kernel is based on floating-point values. Because of this it is not
accpeting a scale argument either, it is expected that the kernel
weights already have the proper sum.

[para] The [arg matrix] has the same general format as the pixel
matrix for method [method {read tcl float}], i.e. a list of lists
(rows) of values, and is treated in the same way, i.e. the number of
columns is the maxium length over the row lists, and shorter lists are
padded with [const 255].  The values are expected to be floating-point
numbers.


[call [cmd ::crimp] [method {kernel transpose}] [arg kernel]]

This method takes a [arg kernel] as returned by the method
[method {kernel make}] and returns a transposed kernel, i.e. one where
the x- and y-axes are switched.

For example
[para][example {
                    (1)
                    (2)
    {1 2 4 2 1} ==> (4)
                    (2)
                    (1)
}][para]

This method is its own inverse, i.e. application to its result returns
the original input, i.e. [example {
    [transpose [transpose $K]] == $K
}]


[call [cmd ::crimp] [method {kernel image}] [arg kernel]]

This method extracts and returns the internal image used to store
the [arg kernel]'s coefficients.


[call [cmd ::crimp] [method map] [arg arg]...]

This method accepts the same sub-methods and arguments as are accepted
by the [method table] method below. In contrast to [method table] the
result is not a list of values, but a map image directly suitable as
argument to the [method remap] method.


[call [cmd ::crimp] [method mapof] [arg table]]

This method accepts a list of 256 values, constructs a map image
directly suitable as argument to the [method remap] method, and
returns this map image as its result.


[call [cmd ::crimp] [method {table compose}] [arg f] [arg g]]

This accepts two lookup tables (aka functions) specified as lists of
256 values, constructs the composite function f(g(x)), and then
returns this new function as its result.


[call [cmd ::crimp] [method {table eval wrap}]  [arg cmd]]
[call [cmd ::crimp] [method {table eval clamp}] [arg cmd]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through the function specified by the command prefix
[arg cmd].

The results returned by the command prefix are rounded to the nearest
integer and then forced into the domain [lb]0..255[rb] by either
wrapping them around (modulo 256), or clamping them to the appropriate
border, i.e 0, and 255 respectively.

[para]

The signature of the command prefix is
[list_begin definitions]
[call [cmd <cmd>] [arg x]]

which is expected to return a number in the range
[lb]0..255[rb]. While the result should be an integer number it is
allowed to be a float, the caller takes care to round the result to
the nearest integer.

[list_end]


[call [cmd ::crimp] [method {table degamma}] [arg y]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through the [fun {inverse gamma correction}] with
parameter [arg y].

This inverse correction, defined in the domain of [lb]0..1[rb] for
both argument and result, is defined as:

[para][image gamma_inv][para]

Scaling of argument and result into the domain [lb]0..255[rb] of pixel
values, and rounding results to the nearest integer, causes the actual
definition used to be

[para][image scaled_gamma_inv]


[call [cmd ::crimp] [method {table gamma}] [arg y]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through the [fun {gamma correction}] with parameter
[arg y].

This correction, defined in the domain of [lb]0..1[rb] for both
argument and result, is defined as:

[para][image gamma][para]

Scaling of argument and result into the domain [lb]0..255[rb] of pixel
values, and rounding results to the nearest integer, causes the actual
definition used to be

[para][image scaled_gamma]


[call [cmd ::crimp] [method {table gauss}] [arg sigma]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through the [fun {sampled gauss}] function with
parameter [arg sigma].

This function is defined as:

[para][image gauss][para]


[call [cmd ::crimp] [method {table identity}]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through the [fun identity] function, which is defined
as

[para][image identity]


[call [cmd ::crimp] [method {table invers}]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through the [fun inverse] function, which is defined
as

[para][image inverse]


[call [cmd ::crimp] [method {table linear wrap}]  [arg gain] [arg offset]]
[call [cmd ::crimp] [method {table linear clamp}] [arg gain] [arg offset]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through a simple linear function with parameters

[arg gain] (the slope) and [arg offset]. The results are rounded to
the nearest integer and then forced into the domain [lb]0..255[rb] by
either wrapping them around (modulo 256), or clamping them to the
appropriate border, i.e 0, and 255 respectively.

Thus the relevant definitions are

[para][image linear_wrap]

for the wrapped case, and

[para][image linear_clamp]

when clamping.


[call [cmd ::crimp] [method {table log}] [opt [arg max]]]
[keywords log-compression]

This method returns a list of 256 values, the result of running the
values 0 to 255 through the [fun {log-compression}] function with
parameter [arg max]. This parameter is the maximum pixel value the
function is for, this value, and all larger will be mapped to 255.

This function is defined as:

[para][image log][para]


[call [cmd ::crimp] [method {table solarize}] [arg threshold]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through the [fun solarize] function, with parameter
[arg threshold]. This function is defined as:

[para][image solarize]
[para]

Note how the function is the [fun identity] for values under the
threshold, and the [fun inverse] for values at and above it. Its
application to an image produces what is known as either
[term solarization] or [term {sabattier effect}].


[call [cmd ::crimp] [method {table sqrt}] [opt [arg max]]]
[keywords sqrt-compression]

This method returns a list of 256 values, the result of running the
values 0 to 255 through the [fun {sqrt-compression}] function with
parameter [arg max]. This parameter is the maximum pixel value the
function is for, this value, and all larger will be mapped to 255.

This function is defined as:

[para][image sqrt][para]


[call [cmd ::crimp] [method {table stretch}] [arg min] [arg max]]

This is a convenience method around [method {table linear}] which maps
[arg min] to 0, and [arg max] to 255, with linear interpolation in
between. Values below [arg min] and above [arg max] are clamped to 0
and 255 respectively.


[call [cmd ::crimp] [method {table threshold above}] [arg threshold]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through a [fun thresholding] (or [term binarization])
function, with parameter [arg threshold]. This function is defined as:

[para][image threshold-ge]
[para]


[call [cmd ::crimp] [method {table threshold below}] [arg threshold]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through a [fun thresholding] (or [term binarization])
function, with parameter [arg threshold]. This function is defined as:

[para][image threshold-le]
[para]


[call [cmd ::crimp] [method {table threshold inside}] [arg min] [arg max]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through a [fun thresholding] (or [term binarization])
function, with parameters [arg min] and [arg max]. This function is
defined as:

[para][image threshold-inside]
[para]


[call [cmd ::crimp] [method {table threshold outside}] [arg min] [arg max]]

This method returns a list of 256 values, the result of running the
values 0 to 255 through a [fun thresholding] (or [term binarization])
function, with parameters [arg min] and [arg max]. This function is
defined as:

[para][image threshold-outside]
[para]


[call [cmd ::crimp] [method {table fgauss discrete}] [arg sigma] [opt [arg r]]]
[call [cmd ::crimp] [method {table fgauss sampled}] [arg sigma] [opt [arg r]]]

This method computes the table for a discrete or sampled gaussian with
parameters [arg sigma] and kernel [arg r]adius. If the radius is not
specified it defaults to the smallest integer greater than
"3*[arg sigma]".


[call [cmd ::crimp] [method {transform affine}] [arg a] [arg b] [arg c] [arg d] [arg e] [arg f]]

This method returns the affine transformation specified by the 2x3
matrix

[example {
    |a b c|
    |d e f|
}]

Note that it is in general easier to use the methods [method rotate],
[method scale], and [method translate] [method scale] to generate the
desired transformation piecemal and then use [method chain] to chain the
pieces together.

[call [cmd ::crimp] [method {transform chain}] [arg transform]...]

This method computes and returns the projective transformation
generated by applying the specified transformations in reverse order,
i.e with the transformation at the end of the argument list applied
first, then the one before it, etc.

[call [cmd ::crimp] [method {transform invert}] [arg transform]]

This method computes and returns the inverse of the specified
projective [arg transform]ation.

[call [cmd ::crimp] [method {transform projective}]  [arg a] [arg b] [arg c] [arg d] [arg e] [arg f] [arg g] [arg h]]

This method returns the projective transformation specified by the 3x3
matrix

[example {
    |a b c|
    |d e f|
    |g h 1|
}]

Note that for the affine subset of projective transformation it is in
general easier to use the methods [method rotate], [method scale], and
[method translate] [method scale] to generate the desired
transformation piecemal and then use [method chain] to chain the pieces
together.

[para] And for a true perspective transformation specification through
[method quadrilateral] should be simpler as well.

[call [cmd ::crimp] [method {transform quadrilateral}] [arg src] [arg dst]]

This method returns the projective transformation which maps the
quadrilateral [arg src] on to the quadrilateral [arg dst].

[para] Each quadrilateral is specified as a list of 4 points, each
point a pair of x- and y-coordinates.

[call [cmd ::crimp] [method {transform rotate}] [arg theta] [opt [arg center]]]

This methods returns the projective transformation which rotates the
image by the anglie [arg theta] around the point [arg center]. If the
latter is not specified {0 0} is assumed. The point, if present, is
specified as pair of x- and y-coordinates.

[para] The angle is specified in degrees, with [const 0] not rotating
the image at all. Positive values cause a counterclockwise rotation,
negative values a clockwise one.

[call [cmd ::crimp] [method {transform scale}] [arg sx] [arg sy]]

This methods returns the projective transformation which scales an
image by factor [arg sx] in width, and [arg sy] in height. Values
larger than [const 1] expand the image along the specified dimension,
while values less than [const 1] shrink it. Negative values flip the
respective axis.

[call [cmd ::crimp] [method {transform translate}] [arg dx] [arg dy]]

This methods returns the projective transformation which translates an
image by [arg dx] pixels along the x-axis, and [arg dx] pixels along
the y-axis. Values larger than [const 0] move the image to the right,
or down, along the specified dimension, while values less than
[const 0] move it to the left, or up.

[list_end]


[subsection Miscellanea]

The package contains a number of primitives which are either not
really useful to a regular user, or have not gotten a nice interface
yet, possibly because it is not clear how that interface should look
like.

[para] These primitives are collected here, so that they are not
forgotten, i.e. as a reminder to either make them properly available,
document as internal/undocumented/etc, or remove them.

[list_begin definitions]

[call [cmd ::crimp::black_white_vertical]]

Generates a fixed checker board image. The output is 256x256
[const grey8] image, with 16x16 blocks. Debug use only, so far.

[call [cmd ::crimp::bilateral_*] [arg image] [arg sigma-space] [arg sigma-range]]
[call [cmd ::crimp::joint_bilateral_*] [arg image] [arg wimage] [arg sigma-space] [arg sigma-range]]

Regular and cross bilateral filters. Still looking buggy, possibly bad
memory accesses.

[call [cmd ::crimp::color_combine] [arg image] [arg vector]]

This operation combines the channels of the input into a single
[const grey8] value, the result of performing a scalar product of each
pixel with the 3x1 [arg vector] ([const float] image).


[call [cmd ::crimp::color_mix] [arg image] [arg matrix]]

This operation mixes the color channels of the input, the result of
performing a matrix multiplication of each pixel with the 3x3
[arg matrix] ([const float] image).

[call [cmd ::crimp::connected_components] [arg image] [arg 8connected]]
[call [cmd ::crimp::connected_components_*] [arg image] [arg 8connected] [arg bgValue]]

Computing (labeling) the connected components of the input image,
using either 4- or 8-neighbourhood. The primitives accepting a
background value use it to distinguish foreground and background and
coalesce the latter into a single component, even if its area is
disconnected.

[para] The result is always of type [const grey32], to have enough
range for the label counters.

[call [cmd ::crimp::euclidean_distance_map_float] [arg image]]
[call [cmd ::crimp::indicator_grey8_float] [arg image]]

These two operations together allow the creation of distance maps from
images, i.e.  watershed diagrams. Currently only used in a
demonstration for this.

[call [cmd ::crimp::hough_grey8] [arg image] [arg emptybucketcolor]]

Hough transformation of an image. Currently only used in a
demonstration so far.

[call [cmd ::crimp::gaussian_01_float] [arg image] [arg derivative] [arg sigma]]
[call [cmd ::crimp::gaussian_10_float] [arg image] [arg derivative] [arg sigma]]
[call [cmd ::crimp::gaussian_blur_float] [arg image] [arg sigma]]
[call [cmd ::crimp::gaussian_laplacian_float] [arg image] [arg sigma]]
[call [cmd ::crimp::gaussian_gradient_mag_float] [arg image] [arg sigma]]

Fast gaussian filters and derivatives, applied in X and Y directions,
i.e. rows and coluimns of the input image. The [arg derivative] is either

[list_begin definitions]
[def [const 0]] Gaussian
[def [const 1]] Gradient
[def [const 2]] Laplacian
[list_end]

[para] The methods [method 01] and [method 10] apply a gaussian or
derivative to the image, in X and Y directions,
respectively. I.e. they operate on the rows, or columns of the image,
respectively.

[para] [method blur] applies a gaussian blur in both directions, i.e.

[example {
    output = gauss10 (gauss01 (image))
}]

[para] [method laplacian] returns an approximation of the scalar
second derivative, the [term laplacian] of the image. It is computed
by applying a laplacian of a gaussian, for both X and Y directions,
and adding the results, i.e.:

[example {
    laplace20 (gauss01 (image)) + laplace02 (gauss20 (image))
}]

[para] [method gradient_mag] returns the magnitude of the image
gradient. It is computed by applying a gradient of gaussian to X and Y
directions, and computing the length of the resulting 2-vector
(euclidean norm), i.e.

[example {
    hypot (gauss10 (grad10 (image)), gauss10 (grad01 (image)))
}]

[call [cmd ::crimp::map_2*_*] [arg image] [arg map]]

Operators applying a piecewise linear [arg map] to the input image.
The map is stored in a Tcl list containing 2 elements, each a
bytearray.  The first stores the abscissaes delineating the intervals,
the second the ordinates at these interval borders. The format of the
binary data depends on the types of input and output values (byte,
int, float, ...).

[para] For conversion a pixel value is searched for in the intervals
of abscissae. With both the interval and the fraction inside of it
known the output is then linearly interpolated from the associated
ordinates. The search is a binary one, assuming that the abscissae are
sorted from smaller to larger. If the input value is outside of the
defined intervals the outputs associated with the min and max
abscissae are returned, respectively.

[para] Not exposed yet, unclear how the higher level API should look
like.

[call [cmd ::crimp::map2_*] [arg image] \
     [arg mapNimage]... \
     [arg mapNcontrol]...]

Primitives applying per-pixel transformations to multi-channel images
(HSV, RGB, RGBA). Each channel is transformed with one map image per
channel, and one integer index per channel selecting the control
channel.

Each map is a 256x256 [const grey8] image indexed by the pixel data of
the channel to be mapped in X, and the pixel data of the chosen
control channel in Y. This enables effects like hue-dependent changes
to saturation or value, value dependent color-shifts, etc.

[para] Not exposed yet, unclear how the higher level API should
look like.

[call [cmd ::crimp::region_sum] [arg image] [arg radius]]
Takes a [term {summed area table}] as input and computes the sums
for square windows of the [arg radius] around each pixel. Time
is constant per pixel, independent of the radius, because of the
nature of the input. Only used internally so far.

[call [cmd ::crimp::exp_float] [arg image]]
[call [cmd ::crimp::log_float] [arg image]]
[call [cmd ::crimp::log10_float] [arg image]]
[call [cmd ::crimp::offset_float] [arg image] [arg offset]]
[call [cmd ::crimp::pow_float_float] [arg imageBase] [arg imageExponent]]
[call [cmd ::crimp::scale_float] [arg image] [arg factor]]
[call [cmd ::crimp::sqrt_float] [arg image]]
Only used internally (or demos), in various calculations like arithmetic mean, standard
deviation, etc. Might be useful in general, as unary operator.

[call [cmd ::crimp::non_max_suppression] [arg imageMagnitude] [arg imageAngle]]
[call [cmd ::crimp::trace_hysteresis] [arg image] [arg low] [arg high]]
Abandoned, part of an older attempt at canny edge detection.

[call [cmd ::crimp::window_*] [arg image]]

[call [cmd ::crimp::window_*] [arg image]]
Window the image by decreasing luma from center to the edges using an
inverse square law. Currently only used internally, as part of the
translational registration. Might be useful in general.

[list_end]



[section References]
[list_begin enumerated]

[enum] Simon Perreault and Patrick Hebert, "Median Filtering in Constant Time", 2007
       [uri http://nomis80.org/ctmf.html]

[enum] Nobuyuki Otsu, "A threshold selection method from gray-level histograms", 1979
       [uri http://en.wikipedia.org/wiki/Otsu%27s_method]

[enum] Leptonica, "The Tophat and H-dome transforms",
       [uri http://www.leptonica.com/grayscale-morphology.html#TOPHAT-HDOME]

[enum] P. Peterlin, "Morphological Operations: An Overview",
       [uri http://www.inf.u-szeged.hu/ssip/1996/morpho/morphology.html]

[enum] Adrien Bousseau, "Mathematical Morphology",
       PDF at [uri http://artis.imag.fr/Members/Adrien.Bousseau/morphology/]

[list_end]

[keywords photo image]
[manpage_end]

