lpt_grey32
Tcl_Obj* imageObj
int width
int height
int hcenter
int vcenter
int xwidth
int xheight
int corners

                    /*   image    :-	 Input Image  to transform 
                     *   width    :-     Width of the input array 
                     *   height	  :-	 Height of the input array 
                     *   hcenter  :-     Location of the Horizontal center 
                     *   vcenter  :-	 Location of the Vertical center 
                     *   xwidth	  :-	 Transform width (number of angular steps) 
                     *   xheight  :-	 Transform height (number of radial steps) 
                     *   corners  :-	 1 == corner pixels desirable, 0 == trim to  a circle 
                     *   Result   :-     Transgormed Image     
                     */

crimp_image* image ;
crimp_image* result ;
float r0 ;			    /* Reference radius for the transform */
float rhoOffset ;		/* Offset to add to the log-radius */
int i, j ;
int phi, rho ;
float rhomax , rmax ;
float* cosines ;		   /* Cosines of angles corresponding
				            * to phi = 0 .. xwidth-1 */
float* sines ;          /* Sines of angles corresponding
				            * to phi = 0 .. xwidth-1 */

crimp_input (imageObj   , image       , grey32);
result = crimp_new_grey32 (xwidth , xheight ) ;

 
#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#define _USE_MATH_DEFINES
#endif
 
for (j = 0; j < result->h; j++) {
    for (i = 0; i < result->w; i++) {
          GREY32 (result ,i  ,j ) = BLACK ;
	}
}   
 	                 /* Maximum radial co-ordinate */
    rmax = 
	( corners ?
	   0.5f * sqrtf( (float) width*width + (float) height*height )
	 : 0.5f * ( (width < height) ? width : height));
				
                        /* Radius at which rho and theta have equal scales. 
                         * Inside r0, rho expands, outside,it contracts. 
						 */
	r0 = xwidth / (2.0f * (float)M_PI);
				
	                    		
    rhomax = 1.0f + r0 * logf(rmax);      /* Maximum possible value of rho */	
    rhoOffset = xheight - rhomax;         /* Offset to use for rho         */

  

   
    /*
     * Filling all the pixel by interpolating
     */

    sines   = (float*) malloc(xwidth * sizeof(float));
    cosines = (float*) malloc(xwidth * sizeof(float));

    for (phi = 0; phi < xwidth; ++phi) {
	float theta = 2.f * (float)M_PI * phi / xwidth;
	cosines[phi] = cosf(theta);
	sines[phi]   = sinf(theta);
    }
    for (rho = 0; rho < xheight; ++rho) {
	float r = expf((rho - rhoOffset) / r0);
	for (phi = 0; phi < xwidth; ++phi) {
	    i = rho * xwidth + phi;
		
		{
		float hh = r * cosines[phi];
		float vv = r * sines[phi];

		int hint0, vint0, hint1, vint1;
		float hfract, vfract;
		float z00, z01, z10, z11;

		if (hh >= -width/2 && hh <= width/2
		    && vv >=-height/2 && vv <= height/2) {
		    hh = hh + hcenter + width;
		    while (hh >= width) hh -= width;
		    vv = vv + vcenter + height;
		    while (vv >= height) vv -= height;

		    hint0 = (int)hh;
		    hfract = hh-hint0;
		    hint1 = (hint0+1) % width;
		    vint0 = (int)vv;
		    vfract = vv-vint0;
		    vint1 = (vint0+1) % height;

		    z00 = GREY32 ( image, hint0 , vint0) ;
		    z10 = GREY32 ( image, hint0 , vint1) ;
		    z01 = GREY32 ( image, hint1 , vint0) ;
		    z11 = GREY32 ( image, hint1 , vint1) ;
		    GREY32 ( result ,phi  ,rho ) = z00 * (1.0f - vfract ) * ( 1.0f - hfract ) 
			                            + z01 * (1.0f - vfract ) *  hfract
			                            + z10 *  vfract          * ( 1.0f - hfract )
		                                + z11 *  vfract          *  hfract;

		}
	    }
	}
    }

    free(sines);
    free(cosines);   
   


Tcl_SetObjResult(interp, crimp_new_image_obj (result));
return TCL_OK;


/* vim: set sts=4 sw=4 tw=80 et ft=c: */
/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */





