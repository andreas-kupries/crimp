
<html><head>
<title>crimp - Image Manipulation</title>
<style type="text/css"><!--
    HTML {
	background: 	#FFFFFF;
	color: 		black;
    }
    BODY {
	background: 	#FFFFFF;
	color:	 	black;
    }
    DIV.doctools {
	margin-left:	10%;
	margin-right:	10%;
    }
    DIV.doctools H1,DIV.doctools H2 {
	margin-left:	-5%;
    }
    H1, H2, H3, H4 {
	margin-top: 	1em;
	font-family:	sans-serif;
	font-size:	large;
	color:		#005A9C;
	background: 	transparent;
	text-align:		left;
    }
    H1.title {
	text-align: center;
    }
    UL,OL {
	margin-right: 0em;
	margin-top: 3pt;
	margin-bottom: 3pt;
    }
    UL LI {
	list-style: disc;
    }
    OL LI {
	list-style: decimal;
    }
    DT {
	padding-top: 	1ex;
    }
    UL.toc,UL.toc UL, UL.toc UL UL {
	font:		normal 12pt/14pt sans-serif;
	list-style:	none;
    }
    LI.section, LI.subsection {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding: 	0em;
    }
    PRE {
	display: 	block;
	font-family:	monospace;
	white-space:	pre;
	margin:		0%;
	padding-top:	0.5ex;
	padding-bottom:	0.5ex;
	padding-left:	1ex;
	padding-right:	1ex;
	width:		100%;
    }
    PRE.example {
	color: 		black;
	background: 	#f5dcb3;
	border:		1px solid black;
    }
    UL.requirements LI, UL.syntax LI {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding:	0em;
    }
    DIV.synopsis {
	color: 		black;
	background: 	#80ffff;
	border:		1px solid black;
	font-family:	serif;
	margin-top: 	1em;
	margin-bottom: 	1em;
    }
    UL.syntax {
	margin-top: 	1em;
	border-top:	1px solid black;
    }
    UL.requirements {
	margin-bottom: 	1em;
	border-bottom:	1px solid black;
    }
--></style>
</head>
<! -- Generated from file '/home/aku/Projects/Tcl/Crimp/fc/embedded/www/files/crimp.html' by tcllib/doctools with format 'html'
   -->
<! -- Copyright &copy; 2010 Andreas Kupries   -- Copyright &copy; 2010 Documentation, Andreas Kupries
   -->
<! -- CVS: $Id$ crimp.n
   -->
<body><div class="doctools">
<hr> [
  <a href="../toc.html">Table Of Contents</a>
| <a href="../index.html">Keyword Index</a>
] <hr>
<h1 class="title">crimp(n) 1.0.1 doc &quot;Image Manipulation&quot;</h1>
<div id="name" class="section"><h2><a name="name">Name</a></h2>
<p>crimp - Image Manipulation (not yet independent of Tk)</p>
</div>
<div id="toc" class="section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="toc">
<li class="section"><a href="#toc">Table Of Contents</a></li>
<li class="section"><a href="#synopsis">Synopsis</a></li>
<li class="section"><a href="#section1">Description</a></li>
<li class="section"><a href="#section2">Images</a></li>
<li class="section"><a href="#section3">Image Types</a></li>
<li class="section"><a href="#section4">General design</a></li>
<li class="section"><a href="#section5">API</a>
<ul>
<li class="subsection"><a href="#subsection1">Accessors</a></li>
<li class="subsection"><a href="#subsection2">Manipulators</a></li>
<li class="subsection"><a href="#subsection3">Converters</a></li>
<li class="subsection"><a href="#subsection4">I/O commands</a></li>
<li class="subsection"><a href="#subsection5">Support</a></li>
</ul>
</li>
<li class="section"><a href="#section6">References</a></li>
<li class="section"><a href="#keywords">Keywords</a></li>
<li class="section"><a href="#copyright">Copyright</a></li>
</ul>
</div>
<div id="synopsis" class="section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="synopsis">
<ul class="requirements">
<li>package require <b class="pkgname">Tcl 8.5</b></li>
<li>package require <b class="pkgname">Tk 8.5</b></li>
<li>package require <b class="pkgname">crimp <span class="opt">?1?</span></b></li>
</ul>
<ul class="syntax">
<li><a href="#1"><b class="cmd">::crimp</b> <b class="method">channels</b> <i class="arg">image</i></a></li>
<li><a href="#2"><b class="cmd">::crimp</b> <b class="method">dimensions</b> <i class="arg">image</i></a></li>
<li><a href="#3"><b class="cmd">::crimp</b> <b class="method">height</b> <i class="arg">image</i></a></li>
<li><a href="#4"><b class="cmd">::crimp</b> <b class="method">histogram</b> <i class="arg">image</i></a></li>
<li><a href="#5"><b class="cmd">::crimp</b> <b class="method">pixel</b> <i class="arg">image</i></a></li>
<li><a href="#6"><b class="cmd">::crimp</b> <b class="method">statistics</b> <i class="arg">image</i></a></li>
<li><a href="#7"><b class="cmd">::crimp</b> <b class="method">type</b> <i class="arg">image</i></a></li>
<li><a href="#8"><b class="cmd">::crimp</b> <b class="method">width</b> <i class="arg">image</i></a></li>
<li><a href="#9"><b class="cmd">::crimp</b> <b class="method">add</b> <i class="arg">image1</i> <i class="arg">image2</i> <span class="opt">?<i class="arg">scale</i>?</span> <span class="opt">?<i class="arg">offset</i>?</span></a></li>
<li><a href="#10"><b class="cmd">::crimp</b> <b class="method">alpha blend</b> <i class="arg">foreground</i> <i class="arg">background</i> <i class="arg">alpha</i></a></li>
<li><a href="#11"><b class="cmd">::crimp</b> <b class="method">alpha set</b> <i class="arg">image</i> <i class="arg">mask</i></a></li>
<li><a href="#12"><b class="cmd">::crimp</b> <b class="method">alpha opaque</b> <i class="arg">image</i></a></li>
<li><a href="#13"><b class="cmd">::crimp</b> <b class="method">alpha over</b> <i class="arg">foreground</i> <i class="arg">background</i></a></li>
<li><a href="#14"><b class="cmd">::crimp</b> <b class="method">blank</b> <i class="arg">type</i> <i class="arg">width</i> <i class="arg">height</i> <i class="arg">value</i>...</a></li>
<li><a href="#15"><b class="cmd">::crimp</b> <b class="method">crop</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></li>
<li><a href="#16"><b class="cmd">::crimp</b> <b class="method">cut</b> <i class="arg">image</i> <i class="arg">x</i> <i class="arg">y</i> <i class="arg">w</i> <i class="arg">h</i></a></li>
<li><a href="#17"><b class="cmd">::crimp</b> <b class="method">decimate</b> <i class="arg">image</i> <i class="arg">factor</i> <i class="arg">kernel</i></a></li>
<li><a href="#18"><b class="cmd">::crimp</b> <b class="method">degamma</b> <i class="arg">image</i> <i class="arg">y</i></a></li>
<li><a href="#19"><b class="cmd">::crimp</b> <b class="method">difference</b> <i class="arg">image1</i> <i class="arg">image2</i></a></li>
<li><a href="#20"><b class="cmd">::crimp</b> <b class="method">downsample</b> <i class="arg">image</i> <i class="arg">factor</i></a></li>
<li><a href="#21"><b class="cmd">::crimp</b> <b class="method">expand const</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i> <span class="opt">?<i class="arg">value</i>...?</span></a></li>
<li><a href="#22"><b class="cmd">::crimp</b> <b class="method">expand extend</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></li>
<li><a href="#23"><b class="cmd">::crimp</b> <b class="method">expand mirror</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></li>
<li><a href="#24"><b class="cmd">::crimp</b> <b class="method">expand replicate</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></li>
<li><a href="#25"><b class="cmd">::crimp</b> <b class="method">expand wrap</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></li>
<li><a href="#26"><b class="cmd">::crimp</b> <b class="method">filter convolve</b> <span class="opt">?<b class="option">-border</b> <i class="arg">spec</i>?</span> <i class="arg">kernel</i>...</a></li>
<li><a href="#27"><b class="cmd">::crimp</b> <b class="method">filter rank</b> <span class="opt">?<b class="option">-border</b> <i class="arg">spec</i>?</span> <span class="opt">?<i class="arg">radius</i> <span class="opt">?<i class="arg">percentile</i>?</span>?</span></a></li>
<li><a href="#28"><b class="cmd">::crimp</b> <b class="method">gamma</b> <i class="arg">image</i> <i class="arg">y</i></a></li>
<li><a href="#29"><b class="cmd">::crimp</b> <b class="method">interpolate</b> <i class="arg">image</i> <i class="arg">factor</i> <i class="arg">kernel</i></a></li>
<li><a href="#30"><b class="cmd">::crimp</b> <b class="method">invert</b> <i class="arg">image</i></a></li>
<li><a href="#31"><b class="cmd">::crimp</b> <b class="method">matrix</b> <i class="arg">image</i> <i class="arg">matrix</i></a></li>
<li><a href="#32"><b class="cmd">::crimp</b> <b class="method">max</b> <i class="arg">image1</i> <i class="arg">image2</i></a></li>
<li><a href="#33"><b class="cmd">::crimp</b> <b class="method">min</b> <i class="arg">image1</i> <i class="arg">image2</i></a></li>
<li><a href="#34"><b class="cmd">::crimp</b> <b class="method">montage horizontal</b> <i class="arg">image</i>...</a></li>
<li><a href="#35"><b class="cmd">::crimp</b> <b class="method">montage vertical</b> <i class="arg">image</i>...</a></li>
<li><a href="#36"><b class="cmd">::crimp</b> <b class="method">morph dilate</b> <i class="arg">image</i></a></li>
<li><a href="#37"><b class="cmd">::crimp</b> <b class="method">morph erode</b> <i class="arg">image</i></a></li>
<li><a href="#38"><b class="cmd">::crimp</b> <b class="method">morph close</b> <i class="arg">image</i></a></li>
<li><a href="#39"><b class="cmd">::crimp</b> <b class="method">morph open</b> <i class="arg">image</i></a></li>
<li><a href="#40"><b class="cmd">::crimp</b> <b class="method">morph gradient</b> <i class="arg">image</i></a></li>
<li><a href="#41"><b class="cmd">::crimp</b> <b class="method">morph igradient</b> <i class="arg">image</i></a></li>
<li><a href="#42"><b class="cmd">::crimp</b> <b class="method">morph egradient</b> <i class="arg">image</i></a></li>
<li><a href="#43"><b class="cmd">::crimp</b> <b class="method">morph tophatw</b> <i class="arg">image</i></a></li>
<li><a href="#44"><b class="cmd">::crimp</b> <b class="method">morph tophatb</b> <i class="arg">image</i></a></li>
<li><a href="#45"><b class="cmd">::crimp</b> <b class="method">multiply</b> <i class="arg">image1</i> <i class="arg">image2</i></a></li>
<li><a href="#46"><b class="cmd">::crimp</b> <b class="method">psychedelia</b> <i class="arg">width</i> <i class="arg">height</i> <i class="arg">frames</i></a></li>
<li><a href="#47"><b class="cmd">::crimp</b> <b class="method">pyramid run</b> <i class="arg">image</i> <i class="arg">steps</i> <i class="arg">stepcmd</i></a></li>
<li><a href="#48"><b class="cmd">&lt;stepcmd&gt;</b> <i class="arg">image</i></a></li>
<li><a href="#49"><b class="cmd">::crimp</b> <b class="method">pyramid gauss</b> <i class="arg">image</i> <i class="arg">steps</i></a></li>
<li><a href="#50"><b class="cmd">::crimp</b> <b class="method">pyramid laplace</b> <i class="arg">image</i> <i class="arg">steps</i></a></li>
<li><a href="#51"><b class="cmd">::crimp</b> <b class="method">remap</b> <i class="arg">image</i> <i class="arg">map</i>...</a></li>
<li><a href="#52"><b class="cmd">::crimp</b> <b class="method">screen</b> <i class="arg">image1</i> <i class="arg">image2</i></a></li>
<li><a href="#53"><b class="cmd">::crimp</b> <b class="method">solarize</b> <i class="arg">image</i> <i class="arg">threshold</i></a></li>
<li><a href="#54"><b class="cmd">::crimp</b> <b class="method">subtract</b> <i class="arg">image1</i> <i class="arg">image2</i> <span class="opt">?<i class="arg">scale</i>?</span> <span class="opt">?<i class="arg">offset</i>?</span></a></li>
<li><a href="#55"><b class="cmd">::crimp</b> <b class="method">threshold global above</b> <i class="arg">image</i> <i class="arg">threshold</i></a></li>
<li><a href="#56"><b class="cmd">::crimp</b> <b class="method">threshold global below</b> <i class="arg">image</i> <i class="arg">threshold</i></a></li>
<li><a href="#57"><b class="cmd">::crimp</b> <b class="method">threshold global inside</b> <i class="arg">image</i> <i class="arg">min</i> <i class="arg">max</i></a></li>
<li><a href="#58"><b class="cmd">::crimp</b> <b class="method">threshold global outside</b> <i class="arg">image</i> <i class="arg">min</i> <i class="arg">max</i></a></li>
<li><a href="#59"><b class="cmd">::crimp</b> <b class="method">threshold local</b> <i class="arg">image</i> <i class="arg">threshold</i>...</a></li>
<li><a href="#60"><b class="cmd">::crimp</b> <b class="method">upsample</b> <i class="arg">image</i> <i class="arg">factor</i></a></li>
<li><a href="#61"><b class="cmd">::crimp</b> <b class="method">wavy</b> <i class="arg">image</i> <i class="arg">offset</i> <i class="arg">adj1</i> <i class="arg">adjb</i></a></li>
<li><a href="#62"><b class="cmd">::crimp</b> <b class="method">flip horizontal</b> <i class="arg">image</i></a></li>
<li><a href="#63"><b class="cmd">::crimp</b> <b class="method">flip transpose</b> <i class="arg">image</i></a></li>
<li><a href="#64"><b class="cmd">::crimp</b> <b class="method">flip transverse</b> <i class="arg">image</i></a></li>
<li><a href="#65"><b class="cmd">::crimp</b> <b class="method">flip vertical</b> <i class="arg">image</i></a></li>
<li><a href="#66"><b class="cmd">::crimp</b> <b class="method">rotate cw</b> <i class="arg">image</i></a></li>
<li><a href="#67"><b class="cmd">::crimp</b> <b class="method">rotate ccw</b> <i class="arg">image</i></a></li>
<li><a href="#68"><b class="cmd">::crimp</b> <b class="method">rotate half</b> <i class="arg">image</i></a></li>
<li><a href="#69"><b class="cmd">::crimp</b> <b class="method">convert 2grey8</b> <i class="arg">image</i></a></li>
<li><a href="#70"><b class="cmd">::crimp</b> <b class="method">convert 2hsv</b> <i class="arg">image</i></a></li>
<li><a href="#71"><b class="cmd">::crimp</b> <b class="method">convert 2rgba</b> <i class="arg">image</i></a></li>
<li><a href="#72"><b class="cmd">::crimp</b> <b class="method">convert 2rgb</b> <i class="arg">image</i></a></li>
<li><a href="#73"><b class="cmd">::crimp</b> <b class="method">join 2hsv</b> <i class="arg">hueImage</i> <i class="arg">satImage</i> <i class="arg">valImage</i></a></li>
<li><a href="#74"><b class="cmd">::crimp</b> <b class="method">join 2rgba</b> <i class="arg">redImage</i> <i class="arg">greenImage</i> <i class="arg">blueImage</i> <i class="arg">alphaImage</i></a></li>
<li><a href="#75"><b class="cmd">::crimp</b> <b class="method">join 2rgb</b> <i class="arg">redImage</i> <i class="arg">greenImage</i> <i class="arg">blueImage</i></a></li>
<li><a href="#76"><b class="cmd">::crimp</b> <b class="method">split</b> <i class="arg">image</i></a></li>
<li><a href="#77"><b class="cmd">::crimp</b> <b class="method">read pgm</b> <i class="arg">string</i></a></li>
<li><a href="#78"><b class="cmd">::crimp</b> <b class="method">read ppm</b> <i class="arg">string</i></a></li>
<li><a href="#79"><b class="cmd">::crimp</b> <b class="method">read strimj</b> <i class="arg">string</i> <span class="opt">?<i class="arg">colormap</i>?</span></a></li>
<li><a href="#80"><b class="cmd">::crimp</b> <b class="method">read tcl grey8</b> <i class="arg">pixelmatrix</i></a></li>
<li><a href="#81"><b class="cmd">::crimp</b> <b class="method">read tcl float</b> <i class="arg">pixelmatrix</i></a></li>
<li><a href="#82"><b class="cmd">::crimp</b> <b class="method">read tk</b> <i class="arg">photo</i></a></li>
<li><a href="#83"><b class="cmd">::crimp</b> <b class="method">write 2tk</b> <i class="arg">photo</i> <i class="arg">image</i></a></li>
<li><a href="#84"><b class="cmd">::crimp</b> <b class="method">write 2string</b> <i class="arg">format</i> <i class="arg">image</i></a></li>
<li><a href="#85"><b class="cmd">::crimp</b> <b class="method">write 2chan</b> <i class="arg">format</i> <i class="arg">chan</i> <i class="arg">image</i></a></li>
<li><a href="#86"><b class="cmd">::crimp</b> <b class="method">write 2file</b> <i class="arg">format</i> <i class="arg">path</i> <i class="arg">image</i></a></li>
<li><a href="#87"><b class="cmd">::crimp</b> <b class="method">kernel make</b> <i class="arg">matrix</i> <span class="opt">?<i class="arg">scale</i>?</span> <span class="opt">?<i class="arg">offset</i>?</span></a></li>
<li><a href="#88"><b class="cmd">::crimp</b> <b class="method">kernel fpmake</b> <i class="arg">matrix</i> <span class="opt">?<i class="arg">offset</i>?</span></a></li>
<li><a href="#89"><b class="cmd">::crimp</b> <b class="method">kernel transpose</b> <i class="arg">kernel</i></a></li>
<li><a href="#90"><b class="cmd">::crimp</b> <b class="method">map</b> <i class="arg">arg</i>...</a></li>
<li><a href="#91"><b class="cmd">::crimp</b> <b class="method">mapof</b> <i class="arg">table</i></a></li>
<li><a href="#92"><b class="cmd">::crimp</b> <b class="method">table compose</b> <i class="arg">f</i> <i class="arg">g</i></a></li>
<li><a href="#93"><b class="cmd">::crimp</b> <b class="method">table eval</b> <span class="opt">?<b class="option">-wrap</b>?</span> <i class="arg">cmd</i></a></li>
<li><a href="#94"><b class="cmd">&lt;cmd&gt;</b> <i class="arg">x</i></a></li>
<li><a href="#95"><b class="cmd">::crimp</b> <b class="method">table degamma</b> <i class="arg">y</i></a></li>
<li><a href="#96"><b class="cmd">::crimp</b> <b class="method">table gamma</b> <i class="arg">y</i></a></li>
<li><a href="#97"><b class="cmd">::crimp</b> <b class="method">table gauss</b> <i class="arg">sigma</i></a></li>
<li><a href="#98"><b class="cmd">::crimp</b> <b class="method">table identity</b></a></li>
<li><a href="#99"><b class="cmd">::crimp</b> <b class="method">table invers</b></a></li>
<li><a href="#100"><b class="cmd">::crimp</b> <b class="method">table linear</b> <span class="opt">?<b class="option">-wrap</b>?</span> <i class="arg">gain</i> <i class="arg">offset</i></a></li>
<li><a href="#101"><b class="cmd">::crimp</b> <b class="method">table log</b> <span class="opt">?<i class="arg">max</i>?</span></a></li>
<li><a href="#102"><b class="cmd">::crimp</b> <b class="method">table solarize</b> <i class="arg">threshold</i></a></li>
<li><a href="#103"><b class="cmd">::crimp</b> <b class="method">table sqrt</b> <span class="opt">?<i class="arg">max</i>?</span></a></li>
<li><a href="#104"><b class="cmd">::crimp</b> <b class="method">table stretch</b> <i class="arg">min</i> <i class="arg">max</i></a></li>
<li><a href="#105"><b class="cmd">::crimp</b> <b class="method">table threshold above</b> <i class="arg">threshold</i></a></li>
<li><a href="#106"><b class="cmd">::crimp</b> <b class="method">table threshold below</b> <i class="arg">threshold</i></a></li>
<li><a href="#107"><b class="cmd">::crimp</b> <b class="method">table threshold inside</b> <i class="arg">min</i> <i class="arg">max</i></a></li>
<li><a href="#108"><b class="cmd">::crimp</b> <b class="method">table threshold outside</b> <i class="arg">min</i> <i class="arg">max</i></a></li>
</ul>
</div>
</div>
<div id="section1" class="section"><h2><a name="section1">Description</a></h2>
<p>This package provides image manipulation commands which are mostly
independent of Tk. The only parts currently depending on Tk are for
the import and export of images from and to Tk photos, necessary for
display.</p>
<p>Note that the intended audience of this document are the users of
<b class="package">crimp</b>. Developers wishing to work on the internals of the
package, but unfamiliar with them, should read ... instead.</p>
</div>
<div id="section2" class="section"><h2><a name="section2">Images</a></h2>
<p>Images are values. This means that they have a string
representation. It is however strongly recommended to not access this
representation at all, and to only use the accessor commands provided
by crimp to obtain the information stored in the internal
representation of image values.</p>
<p>The reason behind this is simple: Memory and speed. Images can be
large. Generating the string representation from the internal one
roughly doubles the memory needed to store it, actually a bit more,
due to the necessary quoting of bytes in UTF-8 and list-quting them as
well. Furthermore such a conversion takes time, roughly proportional
to the size of the image itself, in either direction. Properly
accessing the image information without the package's accessor
commands requires list commands. This causes the loss of the internal
representation, thus forcing later a reconversion to the image's
internal represention when it is used as image again. I.e. the
shimmering forces us to convert twice.</p>
<p>Therefore, to avoid this, use only the crimp commands to access the
images. Even the raw pixel data is accessible in this manner. While
access to that in a Tcl script is, IMHO, highly unusual, there are
situations where it is beneficial. An example of such a situation are
the commands exporting images to raw portable any-maps (PNMs). Our
pixel data fits these formats exactly, and with access to it these
commands could be written in Tcl instead of requiring C level primitives.</p>
</div>
<div id="section3" class="section"><h2><a name="section3">Image Types</a></h2>
<p>Each image has a <i class="term">type</i>, a string implicitly describing features
like the colorspace the image is in, the number of (color) channels,
the domain, i.e. bit-depth, of pixel values in the channels, etc.</p>
<p>All type strings have the form <b class="const">crimp::image::</b><b class="variable">foo</b>.</p>
<p>The package currently knows the following types:</p>
<dl class="definitions">
<dt><b class="const">rgba</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>RGB also known as Red, Green, and Blue.</p></dd>
<dt>Channels</dt>
<dd><p>4, named &quot;red&quot;, &quot;green&quot;, and &quot;blue&quot;,
				plus an &quot;alpha&quot; channel controlling
				pixel opacity.</p></dd>
<dt>Bit-depth</dt>
<dd><p>1 byte/channel (8 bit, values 0-255).</p></dd>
<dt>Pixel-size</dt>
<dd><p>4 bytes.</p></dd>
</dl></dd>
<dt><b class="const">rgb</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>RGB also known as Red, Green, and Blue.</p></dd>
<dt>Channels</dt>
<dd><p>3, named &quot;red&quot;, &quot;green&quot;, and &quot;blue&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>1 byte/channel (8 bit, values 0-255).</p></dd>
<dt>Pixel-size</dt>
<dd><p>3 bytes.</p></dd>
</dl></dd>
<dt><b class="const">hsv</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>HSV, also known as Hue, Saturation, and Value.</p></dd>
<dt>Channels</dt>
<dd><p>3, named &quot;hue&quot;, &quot;saturation&quot;, and &quot;value&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>1 byte/channel (8 bit, values 0-255).</p></dd>
<dt>Pixel-size</dt>
<dd><p>3 bytes.</p></dd>
</dl></dd>
<dt><b class="const">grey8</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>Greyscale.</p></dd>
<dt>Channels</dt>
<dd><p>1, named &quot;luma&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>1 byte/channel (8 bit, values 0-255).</p></dd>
<dt>Pixel-size</dt>
<dd><p>1 byte.</p></dd>
</dl></dd>
<dt><b class="const">grey16</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>Greyscale.</p></dd>
<dt>Channels</dt>
<dd><p>1, named &quot;luma&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>2 byte/channel (16 bit, values 0-65,535).</p></dd>
<dt>Pixel-size</dt>
<dd><p>2 bytes.</p></dd>
</dl></dd>
<dt><b class="const">grey32</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>Greyscale.</p></dd>
<dt>Channels</dt>
<dd><p>1, named &quot;luma&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>4 byte/channel (16 bit, values 0-4,294,967,296).</p></dd>
<dt>Pixel-size</dt>
<dd><p>4 bytes.</p></dd>
</dl></dd>
<dt><b class="const">bw</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>Binary.</p></dd>
<dt>Channels</dt>
<dd><p>1, named &quot;bw&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>1 bit/channel.</p></dd>
<dt>Pixel-size</dt>
<dd><p>1 byte. I.e. 7 bits/channel are wasted.</p></dd>
</dl></dd>
<dt><b class="const">float</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>N.A / Floating Point.</p></dd>
<dt>Channels</dt>
<dd><p>1, named &quot;value&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>4 byte/channel.</p></dd>
<dt>Pixel-size</dt>
<dd><p>4 byte.</p></dd>
</dl></dd>
</dl>
<p>Support for the various types varies by operation. The exact image
types supported by each operation are listed the operation's
description. Invoking an operation for a type it doesn't support will
generally cause it to throw an error.</p>
</div>
<div id="section4" class="section"><h2><a name="section4">General design</a></h2>
<p>All commands operate in a pipeline fashion, taking zero or more image
values, zero or more other arguments, and returning zero or more
images or other values. None are operating in place, i.e. taking an
image variable and writing back to it.</p>
<p>They fall into five categories, namely:</p>
<p><img alt="organization" src="../image/organization.png"></p>
<dl class="definitions">
<dt>Accessors</dt>
<dd><p>They take one or more images, extract information about them, and
return this information as their result. This can be a simple as
querying the image's height, to something as complex as counting pixel
values for a histogram.</p>
<p>The list of accessors, their syntax, and detailed meaning can be found
in section <span class="sectref"><a href="#subsection1">Accessors</a></span>.</p></dd>
<dt>Manipulators</dt>
<dd><p>These take an image and transform its contents in some way, leaving
the image type unchanged. Examples of commands in category are
inversion, gamma conversion, etc. They fall into two sub-categories,
manipulation of the image geometry, and of the intensity values or
colors.</p>
<p>The list of manipulators, their syntax, and detailed meaning can be
found in section <span class="sectref"><a href="#subsection2">Manipulators</a></span>.</p></dd>
<dt>Converters</dt>
<dd><p>Similar to manipulators, except that they change the image's type,
preserving the content instead. Here reside operations like conversion
between the HSV and RGB colorspaces, to greyscale and back, etc.</p>
<p>The list of converters, their syntax, and detailed meaning can be
found in section <span class="sectref"><a href="#subsection3">Converters</a></span>.</p></dd>
<dt>I/O</dt>
<dd><p>Another variant of the same theme, i.e. akin to converters and
manipulators, yet not the same, these commands read and write images
from and to files or other data structures. I.e. they convert between
different serializations of image content and type.</p>
<p>The list of I/O commands, their syntax, and detailed meaning can be
found in section <span class="sectref"><a href="#subsection4">I/O commands</a></span>.</p></dd>
<dt>Support</dt>
<dd><p>Lastly, but not leastly a number of commands, which, while not image
commands themselves, support the others.</p>
<p>The list of supporting commands, their syntax, and detailed meaning
can be found in section <span class="sectref"><a href="#subsection5">Support</a></span>.</p></dd>
</dl>
</div>
<div id="section5" class="section"><h2><a name="section5">API</a></h2>
<div id="subsection1" class="subsection"><h3><a name="subsection1">Accessors</a></h3>
<dl class="definitions">
<dt><a name="1"><b class="cmd">::crimp</b> <b class="method">channels</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns a list containing the names of the channels in the
<i class="arg">image</i>. The order of channels is the same as expected by the
<b class="method">remap</b> method.</p>
<p>The method supports all image types.</p></dd>
<dt><a name="2"><b class="cmd">::crimp</b> <b class="method">dimensions</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns the width and height of the <i class="arg">image</i> (in
pixels).  The result is a 2-element list containing width and height,
in this order.</p>
<p>The method supports all image types.</p></dd>
<dt><a name="3"><b class="cmd">::crimp</b> <b class="method">height</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns the height of the <i class="arg">image</i> (in pixels).</p>
<p>The method supports all image types.</p></dd>
<dt><a name="4"><b class="cmd">::crimp</b> <b class="method">histogram</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns a nested dictionary as its result.  The outer
dictionary is indexed by the names of the channels in the <i class="arg">image</i>.
Its values, the inner dictionaries, are indexed by pixel value. The
associated values are the number of pixels with that value.</p>
<p>The method supports all image types except &quot;grey32&quot;.  Under the
current system the result would be a dictionary with 2^32 keys and
values, taking up, roughly, 192 GiByte of memory in the worst case,
and 96 GiByte in best case (all counter values shared in a single
object).</p></dd>
<dt><a name="5"><b class="cmd">::crimp</b> <b class="method">pixel</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns the raw pixels of the <i class="arg">image</i> as a Tcl ByteArray.</p>
<p>The method supports all image types.</p></dd>
<dt><a name="6"><b class="cmd">::crimp</b> <b class="method">statistics</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns a nested dictionary as its result. The outer dictionary
contains basic information about the image, see the list of keys below.
The inner dictionaries hold data about each (color) channel in the image,
namely histogram and derived data like minumum pixel value, maximum, etc.</p>
<dl class="definitions">
<dt><b class="const">channels</b></dt>
<dd><p>List of the names for the channels in the image.</p></dd>
<dt><b class="const">dimensions</b></dt>
<dd><p>2-element list holding image width and height, in
                         this order.</p></dd>
<dt><b class="const">height</b></dt>
<dd><p>Image height as separate value.</p></dd>
<dt><b class="const">pixels</b></dt>
<dd><p>Number of pixels in the image, the product of
                         its width and height.</p></dd>
<dt><b class="const">type</b></dt>
<dd><p>Type of the image.</p></dd>
<dt><b class="const">width</b></dt>
<dd><p>Image width as separate value.</p></dd>
<dt><b class="const">channel *</b></dt>
<dd><p>Per channel named in key <b class="const">channels</b>, where
                         <b class="const">*</b> is the place holder for the channel name.
                         A dictionary holding the statistics for that channel.</p>
<dl class="definitions">
<dt><b class="const">min</b></dt>
<dd><p>The minimal pixel value with a non-zero population.</p></dd>
<dt><b class="const">max</b></dt>
<dd><p>The maximal pixel value with a non-zero population.</p></dd>
<dt><b class="const">mean</b></dt>
<dd><p>The arithmetic mean of pixel values.</p></dd>
<dt><b class="const">median</b></dt>
<dd><p>The median pixel value.</p></dd>
<dt><b class="const">stddev</b></dt>
<dd><p>The standard deviation of pixel values.</p></dd>
<dt><b class="const">variance</b></dt>
<dd><p>The variance of pixel values, square of the standard
                         deviation.</p></dd>
<dt><b class="const">histogram</b></dt>
<dd><p>A dictionary mapping pixel values to population counts.</p></dd>
<dt><b class="const">hf</b></dt>
<dd><p>The histogram reduced to the population counts, sorted
                         by pixel value to direct indexing into the list by
                         pixel values.</p></dd>
<dt><b class="const">cdf</b></dt>
<dd><p>The <i class="term">cumulative density function</i> of pixel
                         values. The discrete integral of <b class="const">hf</b>.</p></dd>
<dt><b class="const">cdf255</b></dt>
<dd><p>Same as <b class="const">cdf</b>, except scaled down so that the
                         last value in the series is 255.</p></dd>
</dl></dd>
</dl>
<p>The method supports all image types except &quot;grey32&quot;.  Under the
current system the result would contain internal dictionaries with 2^32 keys
and values, taking up, roughly, 192 GiByte of memory in the worst case,
and 96 GiByte in best case (all counter values shared in a single
object).</p></dd>
<dt><a name="7"><b class="cmd">::crimp</b> <b class="method">type</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns the type of the <i class="arg">image</i>.</p>
<p>The method supports all image types.</p></dd>
<dt><a name="8"><b class="cmd">::crimp</b> <b class="method">width</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns the width of the <i class="arg">image</i> (in pixels).</p>
<p>The method supports all image types.</p></dd>
</dl>
</div>
<div id="subsection2" class="subsection"><h3><a name="subsection2">Manipulators</a></h3>
<dl class="definitions">
<dt><a name="9"><b class="cmd">::crimp</b> <b class="method">add</b> <i class="arg">image1</i> <i class="arg">image2</i> <span class="opt">?<i class="arg">scale</i>?</span> <span class="opt">?<i class="arg">offset</i>?</span></a></dt>
<dd><p>This method combines the two input images into a result image by
performing a pixelwise addition (image1 + image2) followed by division
through <i class="arg">scale</i> and addition of the <i class="arg">offset</i>. They default to
<b class="const">1</b> and <b class="const">0</b> respectively, if they are not specified.</p></dd>
<dt><a name="10"><b class="cmd">::crimp</b> <b class="method">alpha blend</b> <i class="arg">foreground</i> <i class="arg">background</i> <i class="arg">alpha</i></a></dt>
<dd><p>This method takes two images of identical dimensions and a blending
factor <i class="arg">alpha</i> and returns an image which is a mix of both, with
each pixel blended per the formula</p>
<p><img alt="blend" src="../image/blend.png"></p>
<p>or, alternatively written</p>
<p><img alt="blend_alt" src="../image/blend_alt.png"></p>
<p>This means that the <i class="arg">foreground</i> is returned as is for
&quot;<i class="arg">alpha</i> == 255&quot;, and the <i class="arg">background</i> for
&quot;<i class="arg">alpha</i> == 0&quot;.
I.e. the argument <i class="arg">alpha</i> controls the <i class="term">opacity</i> of the
foreground, with <b class="const">1</b> and <b class="const">0</b> standing for &quot;fully opaque&quot;
and &quot;fully transparent&quot;, respectively.</p>
<p>The following combinations of fore- and background image types are
supported:</p>
<pre class="example">
    Result = Foreground Background 
    ------   ---------- ---------- 
    grey8    grey8      grey8
    hsv      hsv        hsv
    rgb      rgb        grey8
    rgb      rgb        rgb
    rgb      rgb        rgba
    rgba     rgba       grey8
    rgba     rgba       rgb
    rgba     rgba       rgba
    ------   ---------- ----------
</pre>
</dd>
<dt><a name="11"><b class="cmd">::crimp</b> <b class="method">alpha set</b> <i class="arg">image</i> <i class="arg">mask</i></a></dt>
<dd><p>This command takes two images, the input and a <i class="arg">mask</i>, and returns
an image as result in which the mask is the alpha channel of the
input.
The result is therefore always of type <b class="const">rgba</b>, as the only type
supporting an alpha channel.</p>
<p>The input image can be of type <b class="const">rgb</b> or <b class="const">rgba</b>.  In
case of the latter the existing alpha channel is replaced, in case of
the former an alpha channel is added.</p>
<p>For the mask images of type <b class="const">grey8</b> and <b class="const">rgba</b> are
accepted.  In the case of the latter the mask's alpha channel is used
as the new alpha channel, in case of the former the mask itself is
used.</p></dd>
<dt><a name="12"><b class="cmd">::crimp</b> <b class="method">alpha opaque</b> <i class="arg">image</i></a></dt>
<dd><p>A convenience method over <b class="method">alpha set</b>, giving the <i class="arg">image</i>
a mask which makes it fully opaque.</p></dd>
<dt><a name="13"><b class="cmd">::crimp</b> <b class="method">alpha over</b> <i class="arg">foreground</i> <i class="arg">background</i></a></dt>
<dd><p>This method is similar to <b class="method">blend</b> above, except that there is
no global blending parameter. This information is taken from the
&quot;alpha&quot; channel of the <i class="arg">foreground</i> image instead. The blending
formula is the same, except that the alpha parameter is now a
per-pixel value, and not constant across the image.</p>
<p>Due to the need for an alpha channel the <i class="arg">foreground</i> has to be of
type <b class="const">rgba</b>. For the <i class="arg">background</i> image the types
<b class="const">rgb</b> and <b class="const">rgba</b> are supported.</p></dd>
<dt><a name="14"><b class="cmd">::crimp</b> <b class="method">blank</b> <i class="arg">type</i> <i class="arg">width</i> <i class="arg">height</i> <i class="arg">value</i>...</a></dt>
<dd><p>This method returns a blank image of the given image type and
dimensions.  The <i class="arg">value</i>s after the dimensions are the pixel
values to fill the pixels in the image's channels with, per its type.</p>
<p>This method currently support only the types <b class="const">rgb</b>,
<b class="const">rgba</b>, and <b class="const">grey8</b>.</p></dd>
<dt><a name="15"><b class="cmd">::crimp</b> <b class="method">crop</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></dt>
<dd><p>This method is the counterpart to the <b class="method">expand</b> family of
methods, shrinking an <i class="arg">image</i> by removing a border.
The size of this border is specified by the four arguments <i class="arg">ww</i>,
<i class="arg">hn</i>, <i class="arg">we</i>, and <i class="arg">hs</i> which provide the number of pixels to
remove from the named edge. See the image below for a graphical
representation.</p>
<p><img alt="border" src="../image/border.png"></p></dd>
<dt><a name="16"><b class="cmd">::crimp</b> <b class="method">cut</b> <i class="arg">image</i> <i class="arg">x</i> <i class="arg">y</i> <i class="arg">w</i> <i class="arg">h</i></a></dt>
<dd><p>This method cuts the rectangular region specified throught its <i class="arg">x</i>/<i class="arg">y</i>
position relative to the upper-left corner of the input <i class="arg">image</i> and its
dimensions, and returns it as its own image.</p></dd>
<dt><a name="17"><b class="cmd">::crimp</b> <b class="method">decimate</b> <i class="arg">image</i> <i class="arg">factor</i> <i class="arg">kernel</i></a></dt>
<dd><p>This is a convenience method combining the two steps of filtering an image
(via <b class="method">filter convolve</b>), followed by a <b class="method">downsample</b> step.
See the method <b class="method">interpolate</b> for the complementary operation.</p>
<p>Note that while the <i class="arg">kernel</i> argument for <b class="method">filter convolve</b>
is expected to be the 1D form of a separable low-pass filter no checks are made.
The method simply applies both the kernel and its transposed form.</p>
<p>The method <b class="method">pyramid gauss</b> is a user of this method.</p></dd>
<dt><a name="18"><b class="cmd">::crimp</b> <b class="method">degamma</b> <i class="arg">image</i> <i class="arg">y</i></a></dt>
<dd><p>This method takes an image, runs it through an
<b class="function">inverse gamma correction</b> with parameter <i class="arg">y</i>, and returns
the corrected image as it result.
This is an application of method <b class="method">remap</b>, using the mapping
returned by &quot;<b class="method">map degamma</b> <i class="arg">y</i>&quot;.
This method supports all image types supported by the method
<b class="method">remap</b>.</p></dd>
<dt><a name="19"><b class="cmd">::crimp</b> <b class="method">difference</b> <i class="arg">image1</i> <i class="arg">image2</i></a></dt>
<dd><p>This method combines the two input images into a result image by
taking the pixelwise absolute difference (|image1 - image2|).</p></dd>
<dt><a name="20"><b class="cmd">::crimp</b> <b class="method">downsample</b> <i class="arg">image</i> <i class="arg">factor</i></a></dt>
<dd><p>This method returns an image containing only every <i class="arg">factor</i> pixel of the
input <i class="arg">image</i> (in both dimensions). The effect is that the input is
shrunken by <i class="arg">factor</i>. It is the complement of method <b class="method">upsample</b>.</p>
<p>Using the method as is is not recommended because the simple subsampling
will cause higher image frequencies to alias into the reduced spectrum, causing
artifacts to appear in the result. This is normally avoided by running a
low-pass filter over the image before doing downsampling, removing the
problematic frequencies.</p>
<p>The <b class="method">decimate</b> method is a convenience method combining these
two steps into one.</p></dd>
<dt><a name="21"><b class="cmd">::crimp</b> <b class="method">expand const</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i> <span class="opt">?<i class="arg">value</i>...?</span></a></dt>
<dd></dd>
<dt><a name="22"><b class="cmd">::crimp</b> <b class="method">expand extend</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></dt>
<dd></dd>
<dt><a name="23"><b class="cmd">::crimp</b> <b class="method">expand mirror</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></dt>
<dd></dd>
<dt><a name="24"><b class="cmd">::crimp</b> <b class="method">expand replicate</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></dt>
<dd></dd>
<dt><a name="25"><b class="cmd">::crimp</b> <b class="method">expand wrap</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></dt>
<dd><p>This set of methods takes an image and expands it by adding a border.
The size of this border is specified by the four arguments <i class="arg">ww</i>,
<i class="arg">hn</i>, <i class="arg">we</i>, and <i class="arg">hs</i> which provide the number of pixels to
add at the named edge. See the image below for a graphical
representation.</p>
<p><img alt="border" src="../image/border.png"></p>
<p>The contents of the border's pixels are specified via the border type,
the first argument after <b class="method">expand</b>, as per the list below.</p>
<dl class="definitions">
<dt><b class="method">const</b></dt>
<dd><p>The additional <i class="arg">value</i>s specify the values to use for the color
channels of the image. Values beyond the number of channels in the
image are ignored.
Missing values are generated by replicating the last value, except for
the alpha channel, which will be set to <b class="const">255</b>. If no values are
present they default to <b class="const">0</b>.</p></dd>
<dt><b class="method">extend</b></dt>
<dd><p>This is a combination of <b class="method">mirror</b> and <b class="method">replicate</b>.  The
outside pixels are the result of subtracting the outside pixel for
<b class="method">mirror</b> from the outside pixel for <b class="method">replicate</b> (and
clamping to the range [0...255]).</p></dd>
<dt><b class="method">mirror</b></dt>
<dd><p>The outside pixels take the value of the associated inside pixels,
found by reflecting its coordinates along the relevant edges.</p></dd>
<dt><b class="method">replicate</b></dt>
<dd><p>The outside pixels take the value of the associated edge pixels, i.e.
replicating them into the border.</p></dd>
<dt><b class="method">wrap</b></dt>
<dd><p>The outside pixels take the value of the associated inside pixels,
found by toroidial (cyclic) wrapping its coordinates along the
relevant edges. This is also called tiling.</p></dd>
</dl></dd>
<dt><a name="26"><b class="cmd">::crimp</b> <b class="method">filter convolve</b> <span class="opt">?<b class="option">-border</b> <i class="arg">spec</i>?</span> <i class="arg">kernel</i>...</a></dt>
<dd><p>This method runs the series of filters specified by the convolution
<i class="arg">kernel</i>s over the input and returns the filtered result. See the
method <b class="method">kernel</b> and its sub-methods for commands to create and
manipulate suitable kernels.</p>
<p>The border specification determines how the input image is
expanded (see method <b class="method">expand</b>) to compensate for the shrinkage
introduced by the filter itself. The <i class="arg">spec</i> argument is a list
containing the name of the sub-method of <b class="method">expand</b> to use, plus
any additional arguments this method may need, except for the size of
the expansion.</p>
<p>By default a black frame is used as the border, i.e.
&quot;<i class="arg">spec</i> == {const 0}&quot;.</p></dd>
<dt><a name="27"><b class="cmd">::crimp</b> <b class="method">filter rank</b> <span class="opt">?<b class="option">-border</b> <i class="arg">spec</i>?</span> <span class="opt">?<i class="arg">radius</i> <span class="opt">?<i class="arg">percentile</i>?</span>?</span></a></dt>
<dd><p>This method runs a rank-filter over the input and returns the filtered
result.</p>
<p>The border specification determines how the input image is
expanded (see method <b class="method">expand</b>) to compensate for the shrinkage
introduced by the filter itself. The <i class="arg">spec</i> argument is a list
containing the name of the sub-method of <b class="method">expand</b> to use, plus
any additional arguments this method may need, except for the size of
the expansion.</p>
<p>By default a black frame is used as the border, i.e.
&quot;<i class="arg">spec</i> == {const 0}&quot;.</p>
<p>The <i class="arg">radius</i> specifies the (square) region around each
pixel which is taken into account by the filter, with the pixel value
selected according to the <i class="arg">percentile</i>. The filter region of each
pixel is a square of dimensions &quot;2*<i class="arg">radius</i>+1&quot;, centered around
the pixel.</p>
<p>These two values default to <b class="const">3</b> and <b class="const">50</b>, respectively.</p>
<p>Typical applications of rank-filters are min-, max-, and
median-filters, for percentiles 0, 100, and 50, respectively.</p>
<p>Note that percentiles outside of the range <b class="const">0</b>...<b class="const">100</b>
make no sense and are clamped to this range.</p></dd>
<dt><a name="28"><b class="cmd">::crimp</b> <b class="method">gamma</b> <i class="arg">image</i> <i class="arg">y</i></a></dt>
<dd><p>This method takes an image, runs it through a <b class="function">gamma correction</b>
with parameter <i class="arg">y</i>, and returns the corrected image as it result.
This is an application of method <b class="method">remap</b>, using the mapping
returned by &quot;<b class="method">map gamma</b> <i class="arg">y</i>&quot;.
This method supports all image types supported by the method
<b class="method">remap</b>.</p></dd>
<dt><a name="29"><b class="cmd">::crimp</b> <b class="method">interpolate</b> <i class="arg">image</i> <i class="arg">factor</i> <i class="arg">kernel</i></a></dt>
<dd><p>This is a convenience method combining the two steps of an <b class="method">upsample</b>,
followed by a filter step (via <b class="method">filter convolve</b>). See the method
<b class="method">decimate</b> for the complementary operation.</p>
<p>Note that while the <i class="arg">kernel</i> argument for <b class="method">filter convolve</b>
is expected to be 1D form of a separable low-pass filter no checks are made.
The method simply applies both the kernel and its transposed form.</p>
<p>The methods <b class="method">pyramid gauss</b> and <b class="method">pyramid laplace</b> are
users of this method.</p></dd>
<dt><a name="30"><b class="cmd">::crimp</b> <b class="method">invert</b> <i class="arg">image</i></a></dt>
<dd><p>This method takes an image, runs it through the <b class="function">inverse</b>
function, and returns the modified image as it result.
This is an application of method <b class="method">remap</b>, using the mapping
returned by &quot;<b class="method">map inverse</b>&quot;.
This method supports all image types supported by the method
<b class="method">remap</b>.</p></dd>
<dt><a name="31"><b class="cmd">::crimp</b> <b class="method">matrix</b> <i class="arg">image</i> <i class="arg">matrix</i></a></dt>
<dd><p>This method takes an image and a 3x3 matrix specified as nested Tcl
list (row major order), applies the projective transform represented
by the matrix to the image and returns the transformed image as its
result.</p>
<p>Notes: It is currently unclear how the output pixel is computed
(nearest neighbour, bilinear, etc.) (code inherited from AMG). This
requires more reading, and teasing things apart. The transfomred image
is clipped to the dimensions of the input image, i.e. pixels from the
input may be lost, and pixels in the output may be unset as their
input would come from outside of the input.</p>
<p>The operation supports only images of type <b class="const">rgba</b>, and returns
images of the same type.</p></dd>
<dt><a name="32"><b class="cmd">::crimp</b> <b class="method">max</b> <i class="arg">image1</i> <i class="arg">image2</i></a></dt>
<dd><p>This method combines the two input images into a result image by
taking the pixelwise maximum.</p></dd>
<dt><a name="33"><b class="cmd">::crimp</b> <b class="method">min</b> <i class="arg">image1</i> <i class="arg">image2</i></a></dt>
<dd><p>This method combines the two input images into a result image by
taking the pixelwise minimum.</p></dd>
<dt><a name="34"><b class="cmd">::crimp</b> <b class="method">montage horizontal</b> <i class="arg">image</i>...</a></dt>
<dd></dd>
<dt><a name="35"><b class="cmd">::crimp</b> <b class="method">montage vertical</b> <i class="arg">image</i>...</a></dt>
<dd><p>The result of these methods is an image where the input images have
been placed adjacent to each from left to right (horizontal), or top
to bottom (vertical). The input images have to have the same type, and
the same height, or width, respectively.</p></dd>
<dt><a name="36"><b class="cmd">::crimp</b> <b class="method">morph dilate</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="37"><b class="cmd">::crimp</b> <b class="method">morph erode</b> <i class="arg">image</i></a></dt>
<dd><p>These two methods implement the basic set of morphology operations,
<i class="term"><a href="../index.html#key58">erosion</a></i>, and <i class="term"><a href="../index.html#key15">dilation</a></i> using a flat 3x3 brick as their
structuring element. For grayscale, which we have here, these are,
mathematically, max and min rank-order filters, i.e.</p>
<pre class="example">
    dilate = filter rank 1  0.00 (min)
    erode  = filter rank 1 99.99 (max)
</pre>
</dd>
<dt><a name="38"><b class="cmd">::crimp</b> <b class="method">morph close</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="39"><b class="cmd">::crimp</b> <b class="method">morph open</b> <i class="arg">image</i></a></dt>
<dd><p>These two methods add to the basic set of morphology operations,
<i class="term"><a href="../index.html#key59">opening</a></i> and <i class="term"><a href="../index.html#key7">closing</a></i>. In terms of erosion and dilation:</p>
<pre class="example">
    close = erode o dilate 
    open  = dilate o erode
</pre>
</dd>
<dt><a name="40"><b class="cmd">::crimp</b> <b class="method">morph gradient</b> <i class="arg">image</i></a></dt>
<dd><p>The morphological <i class="term"><a href="../index.html#key63">gradient</a></i> is defined as</p>
<pre class="example">
    [dilate $image] - [erode $image]
</pre>
<p>This can also be expressed as the sum of the external and internal
gradients, see below.</p></dd>
<dt><a name="41"><b class="cmd">::crimp</b> <b class="method">morph igradient</b> <i class="arg">image</i></a></dt>
<dd><p>The morphological <i class="term"><a href="../index.html#key13">internal gradient</a></i> is defined as</p>
<pre class="example">
    $image - [erode image]
</pre>
</dd>
<dt><a name="42"><b class="cmd">::crimp</b> <b class="method">morph egradient</b> <i class="arg">image</i></a></dt>
<dd><p>The morphological <i class="term"><a href="../index.html#key0">external gradient</a></i> is defined as</p>
<pre class="example">
    [dilate $image] - $image
</pre>
</dd>
<dt><a name="43"><b class="cmd">::crimp</b> <b class="method">morph tophatw</b> <i class="arg">image</i></a></dt>
<dd><p>The <i class="term"><a href="../index.html#key38">white tophat</a></i> transformation is defined as</p>
<pre class="example">
    $image - [open $image]
</pre>
</dd>
<dt><a name="44"><b class="cmd">::crimp</b> <b class="method">morph tophatb</b> <i class="arg">image</i></a></dt>
<dd><p>The <i class="term"><a href="../index.html#key22">black tophat</a></i> transformation is defined as</p>
<pre class="example">
    [close $image] - $image
</pre>
</dd>
<dt><a name="45"><b class="cmd">::crimp</b> <b class="method">multiply</b> <i class="arg">image1</i> <i class="arg">image2</i></a></dt>
<dd><p>This method combines the two input images into a result image by
performing a pixelwise multiplication. Note that the result of each
multiplication is divided by <b class="const">255</b> to scale it back into the
range [0...255].</p></dd>
<dt><a name="46"><b class="cmd">::crimp</b> <b class="method">psychedelia</b> <i class="arg">width</i> <i class="arg">height</i> <i class="arg">frames</i></a></dt>
<dd><p>This method creates an <b class="const">rgba</b> image of the specified dimensions
according to an algorithm devised by Andrew M. Goth. The <i class="arg">frames</i>
argument specifies how many images are in the series.</p>
<p><em>Attention:</em> This method keeps internal global state,
ensuring that each call returns a slightly different image. Showing a
series of such images as animation provides an effect similar to a
lava lamp or hallucination.</p></dd>
<dt><a name="47"><b class="cmd">::crimp</b> <b class="method">pyramid run</b> <i class="arg">image</i> <i class="arg">steps</i> <i class="arg">stepcmd</i></a></dt>
<dd><p>This method provides the core functionality for the generation of image
pyramids. The command prefix <i class="arg">stepcmd</i> is run <i class="arg">steps</i> times,
first on the <i class="arg">image</i>, then on the result of the previous step.</p>
<p>The assumed signature of <i class="arg">stepcmd</i> is</p>
<dl class="definitions">
<dt><a name="48"><b class="cmd">&lt;stepcmd&gt;</b> <i class="arg">image</i></a></dt>
<dd><p>which is expected to return a list of two elements. The first element
(<i class="term">result</i>) is added to the pyramid in building, whereas the second
element (<i class="term">iter</i>) is used in the next step as the input of the step
command.</p></dd>
</dl>
<p>The final result of the method is a list containing the input
<i class="arg">image</i> as its first element, followed by the results of the step
function, followed by the <i class="term">iter</i> element returned by the last step,
&quot;<i class="arg">steps</i>+2&quot; images in total.</p>
<p><img alt="pyramid" src="../image/pyramid.png"></p></dd>
<dt><a name="49"><b class="cmd">::crimp</b> <b class="method">pyramid gauss</b> <i class="arg">image</i> <i class="arg">steps</i></a></dt>
<dd><p>This method generates a gaussian image pyramid <i class="arg">steps</i> levels deep and
returns it as a list of images.</p>
<p>The first image in the result is the input, followed by <i class="arg">steps</i>
successively smaller images, each <b class="method">decimate</b>d by a factor two
compared to its predecessor, for a total length of &quot;<i class="arg">steps</i>+1&quot; images.</p>
<p>The convolution part of the decimation uses</p>
<pre class="example"> 1/16 [1 4 6 4 1] </pre>
<p>as its kernel.</p>
<p><img alt="pyramid_gauss" src="../image/pyramid_gauss.png"></p></dd>
<dt><a name="50"><b class="cmd">::crimp</b> <b class="method">pyramid laplace</b> <i class="arg">image</i> <i class="arg">steps</i></a></dt>
<dd><p>This method generates a laplacian image pyramid <i class="arg">steps</i> levels deep and
returns it as a list of images.</p>
<p>The first image in the result is the input, followed by <i class="arg">steps</i>
band pass images (differences of gaussians). The first band pass has the same
size as the input image, and each successor is <b class="method">decimate</b>d by two. This
is followed by one more image, the gaussian of the last step. This image is
decimated by two compared to the preceding bandpass image. In total the result
contains &quot;<i class="arg">steps</i>+2&quot; images.</p>
<p>The convolution part of the decimation uses</p>
<pre class="example"> 1/16 [1 4 6 4 1] </pre>
<p>as its kernel. The internal interpolation used to generate the band pass
images (resynthesis) doubles the weights of this kernel for its convolution
step.</p>
<p><img alt="pyramid_laplace" src="../image/pyramid_laplace.png"></p></dd>
<dt><a name="51"><b class="cmd">::crimp</b> <b class="method">remap</b> <i class="arg">image</i> <i class="arg">map</i>...</a></dt>
<dd><p>This method is the core primitive for the per-pixel transformation of
images, with each pixel (and channels within, if any) handled
independently of all others.
Applications of this operator provided by this package are (inverse)
gamma correction, pixel inversion, and solarization. Many more are
possible, especially when considering other colorspaces like
HSV. There, for example, it is possible change the saturation of
pixels, or shift the hue in arbitrary manner.</p>
<p>Beyond the input <i class="arg">image</i> to transform one or more <i class="term">maps</i> are
specified which define how each pixel value in the input is mapped to
a pixel value in the output. The command will accept at most that many
maps as the input image has channels.  If there are less maps than
channel the last map specified is replicated to cover the other
channels. An exception of this is the handling of the alpha channel,
should the input image have such. There a missing map is handle as
<b class="function">identity</b>, i.e. the channel copied as is, without changes.</p>
<p>The maps are not Tcl data structures, but images themselves.  They
have to be of type <b class="const">grey8</b>, and be of dimension 256x1 (width by
height).</p>
<p>The <b class="method">crimp map ...</b> methods are sources for a number of
predefined maps, whereas the <b class="method">mapof</b> method allows the
construction of maps from Tcl data structures, namely lists of values.</p>
<p>This method supports all image types with one or more
single-byte channels, i.e. all but <b class="const">grey16</b>, <b class="const">grey32</b>,
<b class="const">float</b>, and <b class="const">bw</b>.</p></dd>
<dt><a name="52"><b class="cmd">::crimp</b> <b class="method">screen</b> <i class="arg">image1</i> <i class="arg">image2</i></a></dt>
<dd><p>This method combines the two input images by inverting the
multiplication of the inverted input images. I.e.</p>
<p><img alt="screen" src="../image/screen.png"></p></dd>
<dt><a name="53"><b class="cmd">::crimp</b> <b class="method">solarize</b> <i class="arg">image</i> <i class="arg">threshold</i></a></dt>
<dd><p>This method takes an image, runs it through the <b class="function">solarize</b>
function with parameter <i class="arg">threshold</i>, and returns the modified
image as it result. This is also known as the <i class="term"><a href="../index.html#key51">sabattier effect</a></i>.
This is an application of method <b class="method">remap</b>, using the mapping
returned by &quot;<b class="method">map solarize</b> <i class="arg">threshold</i>&quot;.
This method supports all image types supported by the method
<b class="method">remap</b>.</p></dd>
<dt><a name="54"><b class="cmd">::crimp</b> <b class="method">subtract</b> <i class="arg">image1</i> <i class="arg">image2</i> <span class="opt">?<i class="arg">scale</i>?</span> <span class="opt">?<i class="arg">offset</i>?</span></a></dt>
<dd><p>This method combines the two input images into a result image by
performing a pixelwise subtraction (image1 - image2) followed by
division through <i class="arg">scale</i> and addition of the <i class="arg">offset</i>. They
default to <b class="const">1</b> and <b class="const">0</b> respectively, if they are not
specified.</p></dd>
<dt><a name="55"><b class="cmd">::crimp</b> <b class="method">threshold global above</b> <i class="arg">image</i> <i class="arg">threshold</i></a></dt>
<dd><p>This method takes an image, runs it through the <b class="function">threshold above</b>
function with parameter <i class="arg">threshold</i>, and returns the modified
image as it result. As the result only contains black and white,
i.e. 2 colors, this process is also called <i class="term"><a href="../index.html#key61">binarization</a></i> or
foreground/background segmentation.
This is an application of method <b class="method">remap</b>, using the mapping
returned by &quot;<b class="method">map threshold above</b> <i class="arg">threshold</i>&quot;.
This method supports all image types supported by the method
<b class="method">remap</b>.</p></dd>
<dt><a name="56"><b class="cmd">::crimp</b> <b class="method">threshold global below</b> <i class="arg">image</i> <i class="arg">threshold</i></a></dt>
<dd><p>This method takes an image, runs it through the <b class="function">threshold below</b>
function with parameter <i class="arg">threshold</i>, and returns the modified
image as it result. As the result only contains black and white,
i.e. 2 colors, this process is also called <i class="term"><a href="../index.html#key61">binarization</a></i>, or
foreground/background segmentation.
This is an application of method <b class="method">remap</b>, using the mapping
returned by &quot;<b class="method">map threshold below</b> <i class="arg">threshold</i>&quot;.
This method supports all image types supported by the method
<b class="method">remap</b>.</p></dd>
<dt><a name="57"><b class="cmd">::crimp</b> <b class="method">threshold global inside</b> <i class="arg">image</i> <i class="arg">min</i> <i class="arg">max</i></a></dt>
<dd><p>This method takes an image, runs it through the <b class="function">threshold inside</b>
function with parameters <i class="arg">min</i> and <i class="arg">max</i>, and returns the
modified image as it result. As the result only contains black and
white, i.e. 2 colors, this process is also called <i class="term"><a href="../index.html#key61">binarization</a></i>
or foreground/background segmentation.
This is an application of method <b class="method">remap</b>, using the mapping
returned by &quot;<b class="method">map threshold above</b> <i class="arg">threshold</i>&quot;.
This method supports all image types supported by the method
<b class="method">remap</b>.</p></dd>
<dt><a name="58"><b class="cmd">::crimp</b> <b class="method">threshold global outside</b> <i class="arg">image</i> <i class="arg">min</i> <i class="arg">max</i></a></dt>
<dd><p>This method takes an image, runs it through the <b class="function">threshold outside</b>
function with parameters <i class="arg">min</i> and <i class="arg">max</i>, and returns the
modified image as it result. As the result only contains black and
white, i.e. 2 colors, this process is also called <i class="term"><a href="../index.html#key61">binarization</a></i>,
or foreground/background segmentation.
This is an application of method <b class="method">remap</b>, using the mapping
returned by &quot;<b class="method">map threshold below</b> <i class="arg">threshold</i>&quot;.
This method supports all image types supported by the method
<b class="method">remap</b>.</p></dd>
<dt><a name="59"><b class="cmd">::crimp</b> <b class="method">threshold local</b> <i class="arg">image</i> <i class="arg">threshold</i>...</a></dt>
<dd><p>This method takes an <i class="arg">image</i> and one or more <i class="arg">threshold</i> maps
and returns an image where all pixels of the input which were larger
or equal to the corresponding pixel in the map are set to black. All
other pixels are set to white. Each map is applied to one color
channel of the input image. If there are too many maps the remainder
is ignored. If there are not enough maps the last map is replicated.</p>
<p>This is the core for all methods of non-global
<i class="term"><a href="../index.html#key61">binarization</a></i>, i.e. foreground/background segmentation. Their
differences are just in the calculation of the maps.</p>
<p>This method supports all image types with one or more
single-byte channels, i.e. all but <b class="const">grey16</b>, <b class="const">grey32</b>, and
<b class="const">bw</b>.</p></dd>
<dt><a name="60"><b class="cmd">::crimp</b> <b class="method">upsample</b> <i class="arg">image</i> <i class="arg">factor</i></a></dt>
<dd><p>This method returns an image inserting <i class="arg">factor</i> black pixels between
each pixel of the input <i class="arg">image</i> (in both dimensions). The effect is
that the input is expanded by <i class="arg">factor</i>. It is the complement of
method <b class="method">downsample</b>.</p>
<p>Using the method as is is not recommended because this simple upsampling
will cause copies of the image to appear at the higher image frequencies in the
expanded spectrum. This is normally avoided by running a low-pass filter over
the image after the upsampling, removing the problematic copies.</p>
<p>The <b class="method">interpolate</b> method is a convenience method combining these
two steps into one.</p></dd>
<dt><a name="61"><b class="cmd">::crimp</b> <b class="method">wavy</b> <i class="arg">image</i> <i class="arg">offset</i> <i class="arg">adj1</i> <i class="arg">adjb</i></a></dt>
<dd><p>This method processes the input <i class="arg">image</i> according to an algorithm
devised by Andrew M. Goth, according to the three parameters
<i class="arg">offset</i>, <i class="arg">adj1</i>, and <i class="arg">adjb</i>, and returns the modified
image as its result.</p>
<p>The operation supports only images of type <b class="const">rgba</b>, and returns
images of the same type.</p></dd>
<dt><a name="62"><b class="cmd">::crimp</b> <b class="method">flip horizontal</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="63"><b class="cmd">::crimp</b> <b class="method">flip transpose</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="64"><b class="cmd">::crimp</b> <b class="method">flip transverse</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="65"><b class="cmd">::crimp</b> <b class="method">flip vertical</b> <i class="arg">image</i></a></dt>
<dd><p>This set of methods performs mirroring along the horizontal, vertical
and diagonal axes of the input <i class="arg">image</i>, returning the mirrored
image as their output.  Transpose mirrors along the main diagonal,
transverse along the secondary diagonal.  These two methods also
exchange width and height of the image in the output.</p>
<p>The methods currently support the image types <b class="const">rgb</b>,
<b class="const">rgba</b>, <b class="const">hsv</b>, and <b class="const">grey8</b>.</p></dd>
<dt><a name="66"><b class="cmd">::crimp</b> <b class="method">rotate cw</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="67"><b class="cmd">::crimp</b> <b class="method">rotate ccw</b> <i class="arg">image</i></a></dt>
<dd><p>This set of methods rotates the image in steps of 90 degrees, either
clockwise and counter to it.</p></dd>
<dt><a name="68"><b class="cmd">::crimp</b> <b class="method">rotate half</b> <i class="arg">image</i></a></dt>
<dd><p>This methods rotates the image a half-turn, i.e. 180 degrees.</p></dd>
</dl>
</div>
<div id="subsection3" class="subsection"><h3><a name="subsection3">Converters</a></h3>
<dl class="definitions">
<dt><a name="69"><b class="cmd">::crimp</b> <b class="method">convert 2grey8</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="70"><b class="cmd">::crimp</b> <b class="method">convert 2hsv</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="71"><b class="cmd">::crimp</b> <b class="method">convert 2rgba</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="72"><b class="cmd">::crimp</b> <b class="method">convert 2rgb</b> <i class="arg">image</i></a></dt>
<dd><p>This set of methods all convert their input <i class="arg">image</i> to the
specified type and returns it as their result. All converters accept
an image of the destination type as input and will pass it through
unchanged.</p>
<p>The converters returning a <b class="const">grey8</b> image support <b class="const">rgb</b> and
<b class="const">rgba</b> as their input, using the ITU-R 601-2 luma transform to
merge the three color channels</p>
<p>The converters to HSV support <b class="const">rgb</b> and <b class="const">rgba</b> as their
input as well.</p>
<p>The conversion to <b class="const">rgba</b> accepts only <b class="const">hsv</b> as input,
adding a blank (fully opaque) alpha channel. For more control over the
contents of an image's alpha channel see the methods <b class="method">setalpha</b>
and <b class="method">join rgba</b>.</p>
<p>At last, the conversion to <b class="const">rgb</b> accepts both <b class="const">rgba</b> and
<b class="const">hsv</b> images as input.</p></dd>
<dt><a name="73"><b class="cmd">::crimp</b> <b class="method">join 2hsv</b> <i class="arg">hueImage</i> <i class="arg">satImage</i> <i class="arg">valImage</i></a></dt>
<dd></dd>
<dt><a name="74"><b class="cmd">::crimp</b> <b class="method">join 2rgba</b> <i class="arg">redImage</i> <i class="arg">greenImage</i> <i class="arg">blueImage</i> <i class="arg">alphaImage</i></a></dt>
<dd></dd>
<dt><a name="75"><b class="cmd">::crimp</b> <b class="method">join 2rgb</b> <i class="arg">redImage</i> <i class="arg">greenImage</i> <i class="arg">blueImage</i></a></dt>
<dd><p>This set of methods is the complement of method <b class="method">split</b>. Each
take a set of <b class="const">grey8</b> images and fuse them together into an
image of the given type, with each input image becoming one channel of
the fusing result, which is returned as the result of the command. All
input images have to have the same dimensions.</p></dd>
<dt><a name="76"><b class="cmd">::crimp</b> <b class="method">split</b> <i class="arg">image</i></a></dt>
<dd><p>This method takes an image of one of the multi-channel types, i.e.
<b class="const">rgb</b>, const rgba], and <b class="const">hsv</b> and returns a list of
<b class="const">grey8</b> images, each of which contains the contents of one of
the channels found in the input image.</p>
<p>The channel images in the result are provided in the same order as
they are accepted by the complementary <b class="method">join</b> method, see
above.</p></dd>
</dl>
</div>
<div id="subsection4" class="subsection"><h3><a name="subsection4">I/O commands</a></h3>
<dl class="definitions">
<dt><a name="77"><b class="cmd">::crimp</b> <b class="method">read pgm</b> <i class="arg">string</i></a></dt>
<dd><p>This method returns an image of type <b class="const">grey8</b> containing the data
of the portable grey map (PGM) stored in the <i class="arg">string</i>. The method
recognizes images in both plain and raw sub-formats.</p></dd>
<dt><a name="78"><b class="cmd">::crimp</b> <b class="method">read ppm</b> <i class="arg">string</i></a></dt>
<dd><p>This method returns an image of type <b class="const">rgb</b> containing the data
of the portable pix map (PPM) stored in the <i class="arg">string</i>. The method
recognizes images in both plain and raw sub-formats.</p></dd>
<dt><a name="79"><b class="cmd">::crimp</b> <b class="method">read strimj</b> <i class="arg">string</i> <span class="opt">?<i class="arg">colormap</i>?</span></a></dt>
<dd><p>This method returns an image of type <b class="const">rgba</b> containing the data
of the <i class="term">strimj</i> (string image) (See <a href="http://wiki.tcl.tk/1846">http://wiki.tcl.tk/1846</a>)
stored in the <i class="arg">string</i>.</p>
<p>The caller can override the standard mapping from pixel characters
to colors by specifying a <i class="arg">colormap</i>. This argument is interpreted as
dictionary mapping characters to triples of integers in the range
[0...255], specifying the red, green, and blue intensities.</p>
<p>An example of a strimj is:</p>
<pre class="example">
@...@.......@.@......
@...@.......@.@......
@...@..@@@..@.@..@@@.
@@@@@.@...@.@.@.@...@
@...@.@@@@@.@.@.@...@
@...@.@.....@.@.@...@
@...@.@...@.@.@.@...@
@...@..@@@..@.@..@@@.
</pre>
</dd>
<dt><a name="80"><b class="cmd">::crimp</b> <b class="method">read tcl grey8</b> <i class="arg">pixelmatrix</i></a></dt>
<dd><p>This method takes the <i class="arg">pixelmatrix</i>, a list of rows, with each row
a list of pixel values in the domain [0..255] and returns an
image of type <b class="const">grey8</b> whose height is the number of rows, i.e.
the length of the outer list, and whose width is the maximum length
found among the inner lists. Rows whose inner list is shorter than the
maximum length are padded with black pixels, i.e. a pixel value of
<b class="const">255</b>.</p></dd>
<dt><a name="81"><b class="cmd">::crimp</b> <b class="method">read tcl float</b> <i class="arg">pixelmatrix</i></a></dt>
<dd><p>This method takes the <i class="arg">pixelmatrix</i>, a list of rows, with each row
a list of floating point values for pixel values and returns an image
of type <b class="const">float</b> whose height is the number of rows, i.e.  the
length of the outer list, and whose width is the maximum length found
among the inner lists. Rows whose inner list is shorter than the
maximum length are padded with a pixel value of <b class="const">255</b>.</p></dd>
<dt><a name="82"><b class="cmd">::crimp</b> <b class="method">read tk</b> <i class="arg">photo</i></a></dt>
<dd><p>This method returns an image of type <b class="const">rgba</b> containing the data
from the specified Tk <i class="arg">photo</i> image.</p></dd>
<dt><a name="83"><b class="cmd">::crimp</b> <b class="method">write 2tk</b> <i class="arg">photo</i> <i class="arg">image</i></a></dt>
<dd><p>This method writes the input <i class="arg">image</i> to the specified Tk
<i class="arg">photo</i> image.</p>
<p>The method supports the writing of <b class="const">rgb</b>, <b class="const">rgba</b>,
and <b class="const">grey8</b> images.</p></dd>
<dt><a name="84"><b class="cmd">::crimp</b> <b class="method">write 2string</b> <i class="arg">format</i> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="85"><b class="cmd">::crimp</b> <b class="method">write 2chan</b> <i class="arg">format</i> <i class="arg">chan</i> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="86"><b class="cmd">::crimp</b> <b class="method">write 2file</b> <i class="arg">format</i> <i class="arg">path</i> <i class="arg">image</i></a></dt>
<dd><p>This family of methods either returns the input <i class="arg">image</i> as a
binary string in the specified <i class="arg">format</i>, or writes this string to
the open channel <i class="arg">chan</i>, or the named file at <i class="arg">path</i>.</p>
<p>The image types accepted for writing are <i class="arg">format</i>
dependent, and listed below, with the supported formats.</p>
<p>The currently supported formats are</p>
<dl class="definitions">
<dt><b class="const">pgm-plain</b></dt>
<dd><p>The plain ASCII format of portable grey maps, as per
<a href="http://en.wikipedia.org/wiki/Netpbm_format">http://en.wikipedia.org/wiki/Netpbm_format</a>.</p>
<p>The methods support the writing of <b class="const">rgb</b>, <b class="const">rgba</b>,
<b class="const">hsv</b>, and <b class="const">grey8</b> images.</p></dd>
<dt><b class="const">pgm-raw</b></dt>
<dd><p>The raw binary format of portable grey maps, as per
<a href="http://en.wikipedia.org/wiki/Netpbm_format">http://en.wikipedia.org/wiki/Netpbm_format</a>.</p>
<p>The methods support the writing of <b class="const">rgb</b>, <b class="const">rgba</b>,
<b class="const">hsv</b>, and <b class="const">grey8</b> images.</p></dd>
<dt><b class="const">ppm-plain</b></dt>
<dd><p>The plain ASCII format of portable pix maps, as per
<a href="http://en.wikipedia.org/wiki/Netpbm_format">http://en.wikipedia.org/wiki/Netpbm_format</a>.</p>
<p>The methods support the writing of <b class="const">rgb</b>, <b class="const">rgba</b>,
<b class="const">hsv</b>, and <b class="const">grey8</b> images.</p></dd>
<dt><b class="const">ppm-raw</b></dt>
<dd><p>The raw binary format of portable pix maps, as per
<a href="http://en.wikipedia.org/wiki/Netpbm_format">http://en.wikipedia.org/wiki/Netpbm_format</a>.</p>
<p>The methods support the writing of <b class="const">rgb</b>, <b class="const">rgba</b>,
<b class="const">hsv</b>, and <b class="const">grey8</b> images.</p></dd>
</dl></dd>
</dl>
</div>
<div id="subsection5" class="subsection"><h3><a name="subsection5">Support</a></h3>
<dl class="definitions">
<dt><a name="87"><b class="cmd">::crimp</b> <b class="method">kernel make</b> <i class="arg">matrix</i> <span class="opt">?<i class="arg">scale</i>?</span> <span class="opt">?<i class="arg">offset</i>?</span></a></dt>
<dd><p>This method takes a <i class="arg">matrix</i> of weights and an optional
<i class="arg">scale</i> factor and returns a structure containing the associated
convolution kernel, ready for use by method <b class="method">filter convolve</b>.</p>
<p>If <i class="arg">scale</i> is left unspecified it defaults to the sum of
all weights in the matrix.</p>
<p>If <i class="arg">offset</i> is left unspecified it defaults to 128 if the
sum of weights is 0, and 0 else. In effect zero-sum kernels, like the
basic edge-detectors, are shifted so that results in the range
-128..127 correspond to 0..255.</p>
<p>The <i class="arg">matrix</i> has the same general format as the pixel
matrix for method <b class="method">read tcl grey8</b>, i.e. a list of lists
(rows) of values, and is treated in the same way, i.e. the number of
columns is the maxium length over the row lists, and shorter lists are
padded with <b class="const">128</b>. The values are expected to be integer numbers
in the range -128..127.</p></dd>
<dt><a name="88"><b class="cmd">::crimp</b> <b class="method">kernel fpmake</b> <i class="arg">matrix</i> <span class="opt">?<i class="arg">offset</i>?</span></a></dt>
<dd><p>This method is like <b class="method">kernel make</b> except that the generated
kernel is based on floating-point values. Because of this it is not
accpeting a scale argument either, it is expected that the kernel
weights already have the proper sum.</p>
<p>The <i class="arg">matrix</i> has the same general format as the pixel
matrix for method <b class="method">read tcl float</b>, i.e. a list of lists
(rows) of values, and is treated in the same way, i.e. the number of
columns is the maxium length over the row lists, and shorter lists are
padded with <b class="const">255</b>.  The values are expected to be floating-point
numbers.</p></dd>
<dt><a name="89"><b class="cmd">::crimp</b> <b class="method">kernel transpose</b> <i class="arg">kernel</i></a></dt>
<dd><p>This method takes a <i class="arg">kernel</i> as returned by the method
<b class="method">kernel make</b> and returns a transposed kernel, i.e. one where
the x- and y-axes are switched.
For example</p>
<pre class="example">
                    (1)
                    (2)
    {1 2 4 2 1} ==&gt; (4)
                    (2)
                    (1)
</pre>
<p>This method is its own inverse, i.e. application to its result returns
the original input, i.e.</p>
<pre class="example">
    [transpose [transpose $K]] == $K
</pre>
</dd>
<dt><a name="90"><b class="cmd">::crimp</b> <b class="method">map</b> <i class="arg">arg</i>...</a></dt>
<dd><p>This method accepts the same sub-methods and arguments as are accepted
by the <b class="method">table</b> method below. In contrast to <b class="method">table</b> the
result is not a list of values, but a map image directly suitable as
argument to the <b class="method">remap</b> method.</p></dd>
<dt><a name="91"><b class="cmd">::crimp</b> <b class="method">mapof</b> <i class="arg">table</i></a></dt>
<dd><p>This method accepts a list of 256 values, constructs a map image
directly suitable as argument to the <b class="method">remap</b> method, and
returns this map image as its result.</p></dd>
<dt><a name="92"><b class="cmd">::crimp</b> <b class="method">table compose</b> <i class="arg">f</i> <i class="arg">g</i></a></dt>
<dd><p>This accepts two lookup tables (aka functions) specified as lists of
256 values, constructs the composite function f(g(x)), and then
returns this new function as its result.</p></dd>
<dt><a name="93"><b class="cmd">::crimp</b> <b class="method">table eval</b> <span class="opt">?<b class="option">-wrap</b>?</span> <i class="arg">cmd</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through the function specified by the command prefix
<i class="arg">cmd</i>.
The results returned by the command prefix are rounded to the nearest
integer and then forced into the domain [0..255] by either
wrapping them around (modulo 256), or clamping them to the appropriate
border, i.e 0, and 255 respectively. This is controlled by the
presence of the option <b class="option">-wrap</b>. When present the values are
wrapped, otherwise (default) they are clamped.</p>
<p>The signature of the command prefix is</p>
<dl class="definitions">
<dt><a name="94"><b class="cmd">&lt;cmd&gt;</b> <i class="arg">x</i></a></dt>
<dd><p>which is expected to return a number in the range
[0..255]. While the result should be an integer number it is
allowed to be a float, the caller takes care to round the result to
the nearest integer.</p></dd>
</dl></dd>
<dt><a name="95"><b class="cmd">::crimp</b> <b class="method">table degamma</b> <i class="arg">y</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through the <b class="function">inverse gamma correction</b> with
parameter <i class="arg">y</i>.
This inverse correction, defined in the domain of [0..1] for
both argument and result, is defined as:</p>
<p><img alt="gamma_inv" src="../image/gamma_inv.png"></p>
<p>Scaling of argument and result into the domain [0..255] of pixel
values, and rounding results to the nearest integer, causes the actual
definition used to be</p>
<p><img alt="scaled_gamma_inv" src="../image/scaled_gamma_inv.png"></p></dd>
<dt><a name="96"><b class="cmd">::crimp</b> <b class="method">table gamma</b> <i class="arg">y</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through the <b class="function">gamma correction</b> with parameter
<i class="arg">y</i>.
This correction, defined in the domain of [0..1] for both
argument and result, is defined as:</p>
<p><img alt="gamma" src="../image/gamma.png"></p>
<p>Scaling of argument and result into the domain [0..255] of pixel
values, and rounding results to the nearest integer, causes the actual
definition used to be</p>
<p><img alt="scaled_gamma" src="../image/scaled_gamma.png"></p></dd>
<dt><a name="97"><b class="cmd">::crimp</b> <b class="method">table gauss</b> <i class="arg">sigma</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through the <b class="function">sampled gauss</b> function with
parameter <i class="arg">sigma</i>.
This function is defined as:</p>
<p><img alt="gauss" src="../image/gauss.png"></p></dd>
<dt><a name="98"><b class="cmd">::crimp</b> <b class="method">table identity</b></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through the <b class="function">identity</b> function, which is defined
as</p>
<p><img alt="identity" src="../image/identity.png"></p></dd>
<dt><a name="99"><b class="cmd">::crimp</b> <b class="method">table invers</b></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through the <b class="function">inverse</b> function, which is defined
as</p>
<p><img alt="inverse" src="../image/inverse.png"></p></dd>
<dt><a name="100"><b class="cmd">::crimp</b> <b class="method">table linear</b> <span class="opt">?<b class="option">-wrap</b>?</span> <i class="arg">gain</i> <i class="arg">offset</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through a simple linear function with parameters
<i class="arg">gain</i> (the slope) and <i class="arg">offset</i>. The results are rounded to
the nearest integer and then forced into the domain [0..255] by
either wrapping them around (modulo 256), or clamping them to the
appropriate border, i.e 0, and 255 respectively. This is controlled by
the presence of the option <b class="option">-wrap</b>. When present the values are
wrapped, otherwise (default) they are clamped.
Thus the relevant definitions are</p>
<p><img alt="linear_wrap" src="../image/linear_wrap.png">
for the wrapped case, and</p>
<p><img alt="linear_clamp" src="../image/linear_clamp.png">
when clamping.</p></dd>
<dt><a name="101"><b class="cmd">::crimp</b> <b class="method">table log</b> <span class="opt">?<i class="arg">max</i>?</span></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through the <b class="function">log-compression</b> function with
parameter <i class="arg">max</i>. This parameter is the maximum pixel value the
function is for, this value, and all larger will be mapped to 255.
This function is defined as:</p>
<p><img alt="log" src="../image/log.png"></p></dd>
<dt><a name="102"><b class="cmd">::crimp</b> <b class="method">table solarize</b> <i class="arg">threshold</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through the <b class="function">solarize</b> function, with parameter
<i class="arg">threshold</i>. This function is defined as:</p>
<p><img alt="solarize" src="../image/solarize.png"></p>
<p>Note how the function is the <b class="function">identity</b> for values under the
threshold, and the <b class="function">inverse</b> for values at and above it. Its
application to an image produces what is known as either
<i class="term"><a href="../index.html#key56">solarization</a></i> or <i class="term"><a href="../index.html#key51">sabattier effect</a></i>.</p></dd>
<dt><a name="103"><b class="cmd">::crimp</b> <b class="method">table sqrt</b> <span class="opt">?<i class="arg">max</i>?</span></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through the <b class="function">sqrt-compression</b> function with
parameter <i class="arg">max</i>. This parameter is the maximum pixel value the
function is for, this value, and all larger will be mapped to 255.
This function is defined as:</p>
<p><img alt="sqrt" src="../image/sqrt.png"></p></dd>
<dt><a name="104"><b class="cmd">::crimp</b> <b class="method">table stretch</b> <i class="arg">min</i> <i class="arg">max</i></a></dt>
<dd><p>This is a convenience method around <b class="method">table linear</b> which maps
<i class="arg">min</i> to 0, and <i class="arg">max</i> to 255, with linear interpolation in
between. Values below <i class="arg">min</i> and above <i class="arg">max</i> are clamped to 0
and 255 respectively.</p></dd>
<dt><a name="105"><b class="cmd">::crimp</b> <b class="method">table threshold above</b> <i class="arg">threshold</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through a <b class="function">thresholding</b> (or <i class="term"><a href="../index.html#key61">binarization</a></i>)
function, with parameter <i class="arg">threshold</i>. This function is defined as:</p>
<p><img alt="threshold-ge" src="../image/threshold-ge.png"></p></dd>
<dt><a name="106"><b class="cmd">::crimp</b> <b class="method">table threshold below</b> <i class="arg">threshold</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through a <b class="function">thresholding</b> (or <i class="term"><a href="../index.html#key61">binarization</a></i>)
function, with parameter <i class="arg">threshold</i>. This function is defined as:</p>
<p><img alt="threshold-le" src="../image/threshold-le.png"></p></dd>
<dt><a name="107"><b class="cmd">::crimp</b> <b class="method">table threshold inside</b> <i class="arg">min</i> <i class="arg">max</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through a <b class="function">thresholding</b> (or <i class="term"><a href="../index.html#key61">binarization</a></i>)
function, with parameters <i class="arg">min</i> and <i class="arg">max</i>. This function is
defined as:</p>
<p><img alt="threshold-inside" src="../image/threshold-inside.png"></p></dd>
<dt><a name="108"><b class="cmd">::crimp</b> <b class="method">table threshold outside</b> <i class="arg">min</i> <i class="arg">max</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running the
values 0 to 255 through a <b class="function">thresholding</b> (or <i class="term"><a href="../index.html#key61">binarization</a></i>)
function, with parameters <i class="arg">min</i> and <i class="arg">max</i>. This function is
defined as:</p>
<p><img alt="threshold-outside" src="../image/threshold-outside.png"></p></dd>
</dl>
</div>
</div>
<div id="section6" class="section"><h2><a name="section6">References</a></h2>
<ol class="enumerated">
<li><p>Simon Perreault and Patrick Hebert, &quot;Median Filtering in Constant Time&quot;, 2007
       <a href="http://nomis80.org/ctmf.html">http://nomis80.org/ctmf.html</a></p></li>
</ol>
</div>
<div id="keywords" class="section"><h2><a name="keywords">Keywords</a></h2>
<p><a href="../index.html#key53">affine transform</a>, <a href="../index.html#key6">alpha</a>, <a href="../index.html#key60">alpha blending</a>, <a href="../index.html#key8">alpha channel</a>, <a href="../index.html#key61">binarization</a>, <a href="../index.html#key22">black tophat</a>, <a href="../index.html#key28">blending</a>, <a href="../index.html#key31">channels</a>, <a href="../index.html#key7">closing</a>, <a href="../index.html#key64">composite blending</a>, <a href="../index.html#key52">composition</a>, <a href="../index.html#key3">const expansion</a>, <a href="../index.html#key55">convolution filter</a>, <a href="../index.html#key1">cropping</a>, <a href="../index.html#key9">cut region</a>, <a href="../index.html#key36">cyclic wrap expansion</a>, <a href="../index.html#key15">dilation</a>, <a href="../index.html#key47">dimensions</a>, <a href="../index.html#key21">edge shrinking</a>, <a href="../index.html#key58">erosion</a>, <a href="../index.html#key16">expansion</a>, <a href="../index.html#key34">extend expansion</a>, <a href="../index.html#key0">external gradient</a>, <a href="../index.html#key18">extract rectangle</a>, <a href="../index.html#key57">extract region</a>, <a href="../index.html#key37">filter</a>, <a href="../index.html#key2">flip</a>, <a href="../index.html#key14">gamma correction</a>, <a href="../index.html#key63">gradient</a>, <a href="../index.html#key44">histogram</a>, <a href="../index.html#key40">image</a>, <a href="../index.html#key13">internal gradient</a>, <a href="../index.html#key43">inversion</a>, <a href="../index.html#key20">log-compression</a>, <a href="../index.html#key4">matrix</a>, <a href="../index.html#key35">max</a>, <a href="../index.html#key48">max-filter</a>, <a href="../index.html#key17">median</a>, <a href="../index.html#key26">median-filter</a>, <a href="../index.html#key30">min</a>, <a href="../index.html#key65">min-filter</a>, <a href="../index.html#key46">mirror expansion</a>, <a href="../index.html#key29">montage</a>, <a href="../index.html#key19">morphology</a>, <a href="../index.html#key59">opening</a>, <a href="../index.html#key66">photo</a>, <a href="../index.html#key5">pixel mapping</a>, <a href="../index.html#key24">projective transform</a>, <a href="../index.html#key67">rank-order filter</a>, <a href="../index.html#key39">rectangle cut</a>, <a href="../index.html#key54">rectangle extraction</a>, <a href="../index.html#key45">region cut</a>, <a href="../index.html#key62">remapping</a>, <a href="../index.html#key41">replicate edge expansion</a>, <a href="../index.html#key49">resize</a>, <a href="../index.html#key51">sabattier effect</a>, <a href="../index.html#key33">shrinking</a>, <a href="../index.html#key56">solarization</a>, <a href="../index.html#key10">sqrt-compression</a>, <a href="../index.html#key50">statistics</a>, <a href="../index.html#key12">stddev</a>, <a href="../index.html#key27">thresholding</a>, <a href="../index.html#key25">tophat</a>, <a href="../index.html#key42">toroidal wrap expansion</a>, <a href="../index.html#key32">transform</a>, <a href="../index.html#key11">variance</a>, <a href="../index.html#key38">white tophat</a>, <a href="../index.html#key23">wrap expansion</a></p>
</div>
<div id="copyright" class="section"><h2><a name="copyright">Copyright</a></h2>
<p>Copyright &copy; 2010 Andreas Kupries<br>
Copyright &copy; 2010 Documentation, Andreas Kupries</p>
</div>
</div></body></html>
