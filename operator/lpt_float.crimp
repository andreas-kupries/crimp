lpt_float
Tcl_Obj* imageObj
int width
int height
int hcenter
int vcenter
int xwidth
int xheight
int corners

/*   image    :- Image to transform
 *   width    :- Width of the input image              ** Redundant, can be pulled out
 *   height   :- Height of the input image             ** of the image itself. TODO: Remove.
 *   hcenter  :- Location of the horizontal center
 *   vcenter  :- Location of the vertical center
 *   xwidth   :- Transform width  (number of angular steps)
 *   xheight  :- Transform height (number of radial steps)
 *   corners  :- 1 ==> corner pixels desirable,
 *               0 ==> trim to a circle
 *   Result   :- Transformed image
 */

crimp_image* image;
crimp_image* result;
float        r0;		/* Reference radius for the transform */
float        rhoOffset;		/* Offset to add to the log-radius */
int          i, j;
int          phi, rho;
float        rhomax,  rmax;
float*       cosines;		/* Cosines of angles corresponding
				 * to phi = 0 .. xwidth-1 */
float*       sines;             /* Sines of angles corresponding
				 * to phi = 0 .. xwidth-1 */

crimp_input (imageObj, image, float);

result = crimp_new_float (xwidth, xheight);

#ifdef _MSC_VER
#define _CRT_SECURE_NO_WARNINGS
#define _USE_MATH_DEFINES
#endif

for (j = 0; j < result->h; j++) {
    for (i = 0; i < result->w; i++) {
	FLOATP (result, i , j ) = BLACK;
    }
}

/*
 * Determine the maximum radial co-ordinate
 */
rmax = (corners
	? 0.5f * hypotf (width, height)
	: 0.5f * ((width < height) ? width : height));

/*
 * Determine the radius at which rho and theta have equal scales.
 * Inside r0, rho expands, outside,it contracts.
 */

r0 = xwidth / (2.0f * (float)M_PI);

rhomax    = 1.0f + r0 * logf (rmax);  /* Maximum possible value of rho */
rhoOffset = xheight - rhomax;         /* Offset to use for rho         */

/*
 * Filling all the pixels by interpolating.
 */

sines   = NALLOC (xwidth, float);
cosines = NALLOC (xwidth, float);

for (phi = 0; phi < xwidth; ++phi) {
    float theta = 2.f * (float) M_PI * phi / xwidth;

    cosines[phi] = cosf (theta);
    sines[phi]   = sinf (theta);
}

for (rho = 0; rho < xheight; ++rho) {
    float r = expf((rho - rhoOffset) / r0);

    for (phi = 0; phi < xwidth; ++phi) {
	int hint0, vint0, hint1, vint1;
	float hfract, vfract;
	float z00, z01, z10, z11;
	float hh, vv;

	i = rho * xwidth + phi;

	hh = r * cosines[phi];
	vv = r * sines[phi];

	if ((hh >= -width/2) &&
	    (hh <=  width/2) &&
	    (vv >= -height/2) &&
	    (vv <=  height/2)) {

	    hh = hh + hcenter + width;
	    while (hh >= width) hh -= width;

	    vv = vv + vcenter + height;
	    while (vv >= height) vv -= height;

	    hint0  = (int) hh;
	    hfract = hh - hint0;
	    hint1  = (hint0+1) % width;
	    vint0  = (int) vv;
	    vfract = vv - vint0;
	    vint1  = (vint0+1) % height;

	    z00 = FLOATP (image, hint0, vint0);
	    z10 = FLOATP (image, hint0, vint1);
	    z01 = FLOATP (image, hint1, vint0);
	    z11 = FLOATP (image, hint1, vint1);

	    FLOATP (result, phi, rho) =
		z00 * (1.0f - vfract) * (1.0f - hfract)
		+ z01 * (1.0f - vfract) * hfract
		+ z10 *  vfract         * (1.0f - hfract)
		+ z11 *  vfract         * hfract;
	}
    }
}

ckfree ((char*) sines);
ckfree ((char*) cosines);

Tcl_SetObjResult(interp, crimp_new_image_obj (result));
return TCL_OK;

/* vim: set sts=4 sw=4 tw=80 et ft=c: */
/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
