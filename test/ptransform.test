# -*- tcl -*-
# -------------------------------------------------------------------------

source [file join \
            [file dirname [file join [pwd] [info script]]] \
            testutilities.tcl]

testsNeedTcl     8.5
testsNeedTcltest 2

support { useLocalFile synth.tcl }
support { useC [mainPath _test/lib]/crimp_core* crimp::core no }
testing { useC [mainPath _test/lib]/crimp*      crimp       no }

# -------------------------------------------------------------------------
## Supporting commands, creation and manipulation of projective transforms.
##
## Note: Transforms are 2-element Tcl lists (type tag + 3x3 float image).
##       The second element contains the transform matrix.
# -------------------------------------------------------------------------

test crimp-proj-transform-1.0 {projective transforms, wrong\#args, not enough} -body {
    crimp transform
} -returnCodes error -result {wrong # args: should be "crimp transform subcommand ?argument ...?"}

test crimp-proj-transform-1.1 {projective transforms, invalid method} -body {
    crimp transform BOGUS
} -returnCodes error -result {unknown or ambiguous subcommand "BOGUS": must be affine, chain, identity, invert, projective, quadrilateral, reflect, rotate, scale, shear, or translate}

# -------------------------------------------------------------------------

test crimp-proj-transform-2.0 {projective transforms, raw projective, wrong\#args, not enough} -body {
    crimp transform projective
} -returnCodes error -result {wrong # args: should be "crimp transform projective a b c d e f g h"}

test crimp-proj-transform-2.1 {projective transforms, raw projective, wrong\#args, not enough} -body {
    crimp transform projective A
} -returnCodes error -result {wrong # args: should be "crimp transform projective a b c d e f g h"}

test crimp-proj-transform-2.2 {projective transforms, raw projective, wrong\#args, not enough} -body {
    crimp transform projective A B
} -returnCodes error -result {wrong # args: should be "crimp transform projective a b c d e f g h"}

test crimp-proj-transform-2.3 {projective transforms, raw projective, wrong\#args, not enough} -body {
    crimp transform projective A B C
} -returnCodes error -result {wrong # args: should be "crimp transform projective a b c d e f g h"}

test crimp-proj-transform-2.4 {projective transforms, raw projective, wrong\#args, not enough} -body {
    crimp transform projective A B C D
} -returnCodes error -result {wrong # args: should be "crimp transform projective a b c d e f g h"}

test crimp-proj-transform-2.5 {projective transforms, raw projective, wrong\#args, not enough} -body {
    crimp transform projective A B C D E
} -returnCodes error -result {wrong # args: should be "crimp transform projective a b c d e f g h"}

test crimp-proj-transform-2.6 {projective transforms, raw projective, wrong\#args, not enough} -body {
    crimp transform projective A B C D E F
} -returnCodes error -result {wrong # args: should be "crimp transform projective a b c d e f g h"}

test crimp-proj-transform-2.7 {projective transforms, raw projective, wrong\#args, not enough} -body {
    crimp transform projective A B C D E F G
} -returnCodes error -result {wrong # args: should be "crimp transform projective a b c d e f g h"}

test crimp-proj-transform-2.8 {projective transforms, raw projective, wrong\#args, too many} -body {
    crimp transform projective A B C D E F G H toomuch
} -returnCodes error -result {wrong # args: should be "crimp transform projective a b c d e f g h"}

test crimp-proj-transform-2.9 {projective transforms, raw projective, invalid arguments} -body {
    crimp transform projective A B C D E F G H
} -returnCodes error -result {expected floating-point number but got "A"}

test crimp-proj-transform-2.10 {projective transforms, raw projective, invalid arguments} -body {
    crimp transform projective 0 B C D E F G H
} -returnCodes error -result {expected floating-point number but got "B"}

test crimp-proj-transform-2.11 {projective transforms, raw projective, invalid arguments} -body {
    crimp transform projective 0 0 C D E F G H
} -returnCodes error -result {expected floating-point number but got "C"}

test crimp-proj-transform-2.12 {projective transforms, raw projective, invalid arguments} -body {
    crimp transform projective 0 0 0 D E F G H
} -returnCodes error -result {expected floating-point number but got "D"}

test crimp-proj-transform-2.13 {projective transforms, raw projective, invalid arguments} -body {
    crimp transform projective 0 0 0 0 E F G H
} -returnCodes error -result {expected floating-point number but got "E"}

test crimp-proj-transform-2.14 {projective transforms, raw projective, invalid arguments} -body {
    crimp transform projective 0 0 0 0 0 F G H
} -returnCodes error -result {expected floating-point number but got "F"}

test crimp-proj-transform-2.15 {projective transforms, raw projective, invalid arguments} -body {
    crimp transform projective 0 0 0 0 0 0 G H
} -returnCodes error -result {expected floating-point number but got "G"}

test crimp-proj-transform-2.16 {projective transforms, raw projective, invalid arguments} -body {
    crimp transform projective 0 0 0 0 0 0 0 H
} -returnCodes error -result {expected floating-point number but got "H"}

test crimp-proj-transform-2.17 {projective transforms, raw projective} -body {
    decode_transform \
        [crimp transform projective 0  2  3  4  5  6  7  8]
    #                               sx          sy          scale
    #                                     tx       ty       translate
    #                               r  r     r  r           rotate
    #                                  sx    sy             shear
} -match 4digits -result {
    0 2 3
    4 5 6
    7 8 1
}

# -------------------------------------------------------------------------

test crimp-proj-transform-3.0 {projective transforms, raw affine, wrong\#args, not enough} -body {
    crimp transform affine
} -returnCodes error -result {wrong # args: should be "crimp transform affine a b c d e f"}

test crimp-proj-transform-3.1 {projective transforms, raw affine, wrong\#args, not enough} -body {
    crimp transform affine A
} -returnCodes error -result {wrong # args: should be "crimp transform affine a b c d e f"}

test crimp-proj-transform-3.2 {projective transforms, raw affine, wrong\#args, not enough} -body {
    crimp transform affine A B
} -returnCodes error -result {wrong # args: should be "crimp transform affine a b c d e f"}

test crimp-proj-transform-3.3 {projective transforms, raw affine, wrong\#args, not enough} -body {
    crimp transform affine A B C
} -returnCodes error -result {wrong # args: should be "crimp transform affine a b c d e f"}

test crimp-proj-transform-3.4 {projective transforms, raw affine, wrong\#args, not enough} -body {
    crimp transform affine A B C D
} -returnCodes error -result {wrong # args: should be "crimp transform affine a b c d e f"}

test crimp-proj-transform-3.5 {projective transforms, raw affine, wrong\#args, not enough} -body {
    crimp transform affine A B C D E
} -returnCodes error -result {wrong # args: should be "crimp transform affine a b c d e f"}

test crimp-proj-transform-3.6 {projective transforms, raw affine, wrong\#args, too many} -body {
    crimp transform affine A B C D E F toomuch
} -returnCodes error -result {wrong # args: should be "crimp transform affine a b c d e f"}

test crimp-proj-transform-3.7 {projective transforms, raw affine, invalid arguments} -body {
    crimp transform affine A B C D E F
} -returnCodes error -result {expected floating-point number but got "A"}

test crimp-proj-transform-3.8 {projective transforms, raw affine, invalid arguments} -body {
    crimp transform affine 0 B C D E F
} -returnCodes error -result {expected floating-point number but got "B"}

test crimp-proj-transform-3.9 {projective transforms, raw affine, invalid arguments} -body {
    crimp transform affine 0 0 C D E F
} -returnCodes error -result {expected floating-point number but got "C"}

test crimp-proj-transform-3.10 {projective transforms, raw affine, invalid arguments} -body {
    crimp transform affine 0 0 0 D E F
} -returnCodes error -result {expected floating-point number but got "D"}

test crimp-proj-transform-3.11 {projective transforms, raw affine, invalid arguments} -body {
    crimp transform affine 0 0 0 0 E F
} -returnCodes error -result {expected floating-point number but got "E"}

test crimp-proj-transform-3.12 {projective transforms, raw affine, invalid arguments} -body {
    crimp transform affine 0 0 0 0 0 F
} -returnCodes error -result {expected floating-point number but got "F"}

test crimp-proj-transform-3.13 {projective transforms, raw affine} -body {
    decode_transform \
        [crimp transform affine 0  2  3  4  5  6]
    #                           sx          sy          scale
    #                                 tx       ty       translate
    #                           r  r     r  r           rotate
    #                              sx    sy             shear
} -match 4digits -result {
    0 2 3
    4 5 6
    0 0 1
}

# -------------------------------------------------------------------------

test crimp-proj-transform-4.0 {projective transforms, translate, wrong\#args, not enough} -body {
    crimp transform translate
} -returnCodes error -result {wrong # args: should be "crimp transform translate dx dy"}

test crimp-proj-transform-4.1 {projective transforms, translate, wrong\#args, not enough} -body {
    crimp transform translate DX
} -returnCodes error -result {wrong # args: should be "crimp transform translate dx dy"}

test crimp-proj-transform-4.2 {projective transforms, translate, wrong\#args, too many} -body {
    crimp transform translate DX DY toomuch
} -returnCodes error -result {wrong # args: should be "crimp transform translate dx dy"}

test crimp-proj-transform-4.3 {projective transforms, translate, invalid arguments} -body {
    crimp transform translate DX DY
} -returnCodes error -result {expected floating-point number but got "DX"}

test crimp-proj-transform-4.4 {projective transforms, translate, invalid arguments} -body {
    crimp transform translate 0 DY
} -returnCodes error -result {expected floating-point number but got "DY"}

test crimp-proj-transform-4.5 {projective transforms, translate} -body {
    decode_transform \
        [crimp transform translate 2 3]
} -match 4digits -result {
    1 0 2
    0 1 3
    0 0 1
}

# -------------------------------------------------------------------------
## Randomized testing. Translation.

apply {{} {
    set n 0
    foreach _ [iota 500] {
        lassign [a-translation] p r d

        test crimp-proj-transform-4.6.$n "projective transforms, translate, fuzz" -setup {
            set t [crimp transform translate {*}$d]
        } -body {
            lindex [crimp warp point $t $p] 0
        } -cleanup {
            unset t
        } -result $r -match epsilon
        # With double we have match to the full precision.
        # With float we were restricted to 4digits.
        incr n
    }
}}

# -------------------------------------------------------------------------

test crimp-proj-transform-5.0 {projective transforms, scale, wrong\#args, not enough} -body {
    crimp transform scale
} -returnCodes error -result {wrong # args: should be "crimp transform scale sx sy ?p?"}

test crimp-proj-transform-5.1 {projective transforms, scale, wrong\#args, not enough} -body {
    crimp transform scale SX
} -returnCodes error -result {wrong # args: should be "crimp transform scale sx sy ?p?"}

test crimp-proj-transform-5.2 {projective transforms, scale, wrong\#args, too many} -body {
    crimp transform scale SX SY P toomuch
} -returnCodes error -result {wrong # args: should be "crimp transform scale sx sy ?p?"}

test crimp-proj-transform-5.3 {projective transforms, scale, invalid arguments} -body {
    crimp transform scale SX 1
} -returnCodes error -result {expected floating-point number but got "SX"}

test crimp-proj-transform-5.4 {projective transforms, scale, invalid arguments} -body {
    crimp transform scale 1 SY
} -returnCodes error -result {expected floating-point number but got "SY"}

test crimp-proj-transform-5.5 {projective transforms, scale, invalid arguments} -body {
    crimp transform scale 1 1 P
} -returnCodes error -result {expected 2d point but got "P"}

test crimp-proj-transform-5.6 {projective transforms, scale, invalid arguments} -body {
    crimp transform scale 1 1 {X 0}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-5.7 {projective transforms, scale, invalid arguments} -body {
    crimp transform scale 1 1 {0 Y}
} -returnCodes error -result {expected floating-point number but got "Y"}

test crimp-proj-transform-5.6 {projective transforms, scale} -body {
    decode_transform \
        [crimp transform scale 0 0]
    # possible todo: scale to nothing. non-invertible ?! reject zero ?
} -match 4digits -result {
    0 0 0
    0 0 0
    0 0 1
}

test crimp-proj-transform-5.7 {projective transforms, scale} -body {
    decode_transform \
        [crimp transform scale 1 1]
} -match 4digits -result {
    1 0 0
    0 1 0
    0 0 1
}

test crimp-proj-transform-5.8 {projective transforms, scale} -body {
    decode_transform \
        [crimp transform scale 5 -0.5]
} -match 4digits -result {
    5.0  0.0  0.0
    0.0 -0.5  0.0
    0.0  0.0  1.0
}

test crimp-proj-transform-5.9 {projective transforms, scale} -body {
    decode_transform \
        [crimp transform scale 0.5 -5]
} -match 4digits -result {
    0.5  0.0  0
    0.0 -5.0  0
    0.0  0.0  1
}

test crimp-proj-transform-5.7 {projective transforms, scale about point != null} -body {
    decode_transform \
        [crimp transform scale 2 2 {4 3}]
} -match 4digits -result {
    2 0 -4
    0 2 -3
    0 0  1
}

# -------------------------------------------------------------------------
## Randomized testing. Scaling.

apply {{} {
    set n 0
    foreach _ [iota 500] {
        lassign [a-scaling] p r f c

        test crimp-proj-transform-5.9.$n "projective transforms, scaling, fuzz" -setup {
            set t [crimp transform scale {*}$f $c]
        } -body {
            lindex [crimp warp point $t $p] 0
        } -cleanup {
            unset t
        } -result $r -match 10digits
        # With double we match to within 10 digits.
        # For float the precision was only to within 2 digits!

        incr n
    }
}}

# -------------------------------------------------------------------------

test crimp-proj-transform-6.0 {projective transforms, shear, wrong\#args, not enough} -body {
    crimp transform shear
} -returnCodes error -result {wrong # args: should be "crimp transform shear sx sy"}

test crimp-proj-transform-6.1 {projective transforms, shear, wrong\#args, not enough} -body {
    crimp transform shear SX
} -returnCodes error -result {wrong # args: should be "crimp transform shear sx sy"}

test crimp-proj-transform-6.2 {projective transforms, shear, wrong\#args, too many} -body {
    crimp transform shear SX SY toomuch
} -returnCodes error -result {wrong # args: should be "crimp transform shear sx sy"}

test crimp-proj-transform-6.3 {projective transforms, shear, invalid arguments} -body {
    crimp transform shear SX 0
} -returnCodes error -result {expected floating-point number but got "SX"}

test crimp-proj-transform-6.4 {projective transforms, shear, invalid arguments} -body {
    crimp transform shear 0 SY
} -returnCodes error -result {expected floating-point number but got "SY"}

test crimp-proj-transform-6.5 {projective transforms, shear} -body {
    decode_transform \
        [crimp transform shear 0 0]
} -match 4digits -result {
    1 0 0
    0 1 0
    0 0 1
}

test crimp-proj-transform-6.6 {projective transforms, shear} -body {
    decode_transform \
        [crimp transform shear 3 4]
} -match 4digits -result {
    1 4 0
    3 1 0
    0 0 1
}

test crimp-proj-transform-6.6 {projective transforms, shear} -body {
    decode_transform \
        [crimp transform shear -3 -4]
} -match 4digits -result {
     1 -4 0
    -3  1 0
     0  0 1
}

# -------------------------------------------------------------------------
## Randomized testing. Shearing

apply {{} {
    set n 0
    foreach _ [iota 500] {
        lassign [a-shear] p r s

        test crimp-proj-transform-6.7.$n "projective transforms, shear, fuzz" -setup {
            set t [crimp transform shear {*}$s]
        } -body {
            lindex [crimp warp point $t $p] 0
        } -cleanup {
            unset t
        } -result $r -match 12digits
        # For double we match to within 12 digits.
        # For float the precision matched only to within 4 digits!

        incr n
    }
}}

# -------------------------------------------------------------------------

test crimp-proj-transform-7.0 {projective transforms, reflect, wrong\#args, not enough} -body {
    crimp transform reflect
} -returnCodes error -result {wrong # args: should be "crimp transform reflect subcommand ?argument ...?"}

test crimp-proj-transform-7.1 {projective transforms, invalid method} -body {
    crimp transform reflect BOGUS
} -returnCodes error -result {unknown or ambiguous subcommand "BOGUS": must be line, x, or y}

# -------------------------------------------------------------------------

test crimp-proj-transform-8.0 {projective transforms, reflect @ line, wrong\#args, not enough} -body {
    crimp transform reflect line
} -returnCodes error -result {wrong # args: should be "crimp transform reflect line a ?b?"}

test crimp-proj-transform-8.1 {projective transforms, reflect @ line, wrong\#args, too many} -body {
    crimp transform reflect line A B toomuch
} -returnCodes error -result {wrong # args: should be "crimp transform reflect line a ?b?"}

test crimp-proj-transform-8.2 {projective transforms, reflect @ line, wrong\#args, invalid arguments} -body {
    crimp transform reflect line A
} -returnCodes error -result {expected 2d point but got "A"}

test crimp-proj-transform-8.3 {projective transforms, reflect @ line, wrong\#args, invalid arguments} -body {
    crimp transform reflect line {X 0}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-8.4 {projective transforms, reflect @ line, wrong\#args, invalid arguments} -body {
    crimp transform reflect line {0 Y}
} -returnCodes error -result {expected floating-point number but got "Y"}

test crimp-proj-transform-8.5 {projective transforms, reflect @ line, invalid arguments} -body {
    crimp transform reflect line {0 0} B
} -returnCodes error -result {expected 2d point but got "B"}

test crimp-proj-transform-8.6 {projective transforms, reflect @ line, invalid arguments} -body {
    crimp transform reflect line {0 0} {X 0}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-8.7 {projective transforms, reflect @ line, invalid arguments} -body {
    crimp transform reflect line {0 0} {0 Y}
} -returnCodes error -result {expected floating-point number but got "Y"}

test crimp-proj-transform-8.8 {projective transforms, reflect @ line, invalid arguments} -body {
    astclf 4 [crimp transform reflect line {0 0}]
    # Reflection at (0,0) is unspecified, we have no direction for the vector.
} -returnCodes error -result {Expected non-null vector, got (0, 0)}

test crimp-proj-transform-8.9 {projective transforms, reflect @ line} -body {
    decode_transform \
        [crimp transform reflect line {5 5}]
} -match 4digits -result {
    0 1 0
    1 0 0
    0 0 1
}

# Note: 8.10 and 8.11 specify the same line, just using vector of
# different magnitude along it. The transform must be same.

test crimp-proj-transform-8.10 {projective transforms, reflect @ line} -body {
    decode_transform \
        [crimp transform reflect line {10 10}]
} -match 4digits -result {
    0 1 0
    1 0 0
    0 0 1
}

test crimp-proj-transform-8.11 {projective transforms, reflect @ line} -body {
    decode_transform \
        [crimp transform reflect line {5 10}]
} -match 4digits -result {
    -0.6  0.8  0
     0.8  0.6  0
     0.0  0.0  1
}

test crimp-proj-transform-8.12 {projective transforms, reflect @ line} -body {
    decode_transform \
        [crimp transform reflect line {10 5}]
} -match 4digits -result {
    0.6000   0.8000  0.0000
    0.8000  -0.6000  0.0000
    0.0000   0.0000  1.0000
}

test crimp-proj-transform-8.13 {projective transforms, reflect @ line, invalid arguments} -body {
    crimp transform reflect line {5 5} {5 5}
    # Reflection at (0,0) is unspecified, we have no direction for the
    # vector.
} -returnCodes error -result {Expected non-null vector, got (0, 0)}

test crimp-proj-transform-8.14 {projective transforms, reflect @ line} -body {
    decode_transform \
        [crimp transform reflect line {0 0} {5 5}]
} -match 4digits -result {
    0 1 0
    1 0 0
    0 0 1
}

test crimp-proj-transform-8.15 {projective transforms, reflect @ line} -body {
    decode_transform \
        [crimp transform reflect line {2 0} {5 5}]
} -match 4digits -result {
    -0.4706 0.8824  2.9412
     0.8824 0.4706 -1.7647
     0.0000 0.0000  1.0000
}

# -------------------------------------------------------------------------
## Randomized testing. Reflection along arbitrary line.

apply {{} {
    set n 0
    foreach _ [iota 500] {
        lassign [a-reflection] p r a b

        test crimp-proj-transform-8.16.$n "projective transforms, reflection, fuzz" -setup {
            set t [crimp transform reflect line $a $b]
        } -body {
            lindex [crimp warp point $t $p] 0
        } -cleanup {
            unset t
        } -result $r -match 12digits
        # For double we match to within 12 digits.
        # For float the precision matched only to within 4 digits!

        incr n
    }
}}

# -------------------------------------------------------------------------

test crimp-proj-transform-9.0 {projective transforms, reflect @ x-axis, wrong\#args, too many} -body {
    crimp transform reflect x TOOMUCH
} -returnCodes error -result {wrong # args: should be "crimp transform reflect x"}

test crimp-proj-transform-9.1 {projective transforms, reflect @ x-axis} -body {
    decode_transform \
        [crimp transform reflect x]
} -match 4digits -result {
    -1 0 0
     0 1 0
     0 0 1
}

# -------------------------------------------------------------------------

test crimp-proj-transform-10.0 {projective transforms, reflect @ y-axis, wrong\#args, too many} -body {
    crimp transform reflect y TOOMUCH
} -returnCodes error -result {wrong # args: should be "crimp transform reflect y"}

test crimp-proj-transform-10.1 {projective transforms, reflect @ y-axis} -body {
    decode_transform \
        [crimp transform reflect y]
} -match 4digits -result {
    1  0 0
    0 -1 0
    0  0 1
}

# -------------------------------------------------------------------------

test crimp-proj-transform-11.0 {projective transforms, rotate, wrong\#args, not enough} -body {
    crimp transform rotate
} -returnCodes error -result {wrong # args: should be "crimp transform rotate theta ?p?"}

test crimp-proj-transform-11.1 {projective transforms, rotate, wrong\#args, too many} -body {
    crimp transform rotate THETA P toomuch
} -returnCodes error -result {wrong # args: should be "crimp transform rotate theta ?p?"}

test crimp-proj-transform-11.2 {projective transforms, rotate, invalid arguments} -body {
    crimp transform rotate THETA P
} -returnCodes error -result {expected floating-point number but got "THETA"}

test crimp-proj-transform-11.3 {projective transforms, rotate, invalid arguments} -body {
    crimp transform rotate 1 P
} -returnCodes error -result {expected 2d point but got "P"}

test crimp-proj-transform-11.4 {projective transforms, rotate, invalid arguments} -body {
    crimp transform rotate 1 {X Y}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-11.5 {projective transforms, rotate, invalid arguments} -body {
    crimp transform rotate 1 {0 Y}
} -returnCodes error -result {expected floating-point number but got "Y"}

test crimp-proj-transform-11.6 {projective transforms, rotate} -body {
    decode_transform \
        [crimp transform rotate 2 {-50 -50}]
} -match 4digits -result {
     0.9994  0.0349  1.7145
    -0.0349  0.9994 -1.7754
     0.0000  0.0000  1.0000
}

test crimp-proj-transform-11.7 {projective transforms, rotate, origin} -body {
    decode_transform \
        [crimp transform rotate 1]
} -match 4digits -result {
     0.9998  0.0175  0.0000
    -0.0175  0.9998  0.0000
     0.0000  0.0000  1.0000
}

# -------------------------------------------------------------------------
## Randomized testing. Rotation around arbitrary point.

apply {{} {
    set n 0
    foreach _ [iota 500] {
        lassign [a-rotation] p r c a

        test crimp-proj-transform-11.7.$n "projective transforms, rotation, fuzz" -setup {
            set t [crimp transform rotate $a $c]
        } -body {
            lindex [crimp warp point $t $p] 0
        } -cleanup {
            unset t
        } -result $r -match -1digits
        # Even for double the precision is not even to within 0 digits!
        # Investigate, I suspect some code path is going through single-precision still.

        incr n
    }
}}

# -------------------------------------------------------------------------

test crimp-proj-transform-12.0 {projective transforms, quadrilateral, wrong\#args, not enough} -body {
    crimp transform quadrilateral
} -returnCodes error -result {wrong # args: should be "crimp transform quadrilateral src dst"}

test crimp-proj-transform-12.1 {projective transforms, quadrilateral, wrong\#args, not enough} -body {
    crimp transform quadrilateral SRC
} -returnCodes error -result {wrong # args: should be "crimp transform quadrilateral src dst"}

test crimp-proj-transform-12.2 {projective transforms, quadrilateral, wrong\#args, too many} -body {
    crimp transform quadrilateral SRC DST toomuch
} -returnCodes error -result {wrong # args: should be "crimp transform quadrilateral src dst"}

test crimp-proj-transform-12.3 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral SRC DST
} -returnCodes error -result {expected 4-element quadrilateral but got "SRC"}

test crimp-proj-transform-12.4 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} DST
} -returnCodes error -result {expected 4-element quadrilateral but got "DST"}

test crimp-proj-transform-12.5 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {X {0 0} {0 0} {0 0}} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected 2d point but got "X"}

test crimp-proj-transform-12.6 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} X {0 0} {0 0}} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected 2d point but got "X"}

test crimp-proj-transform-12.7 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} X 0} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected 2d point but got "X"}

test crimp-proj-transform-12.8 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} X} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected 2d point but got "X"}

test crimp-proj-transform-12.9 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {X {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected 2d point but got "X"}

test crimp-proj-transform-12.10 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{0 0} X {0 0} {0 0}}
} -returnCodes error -result {expected 2d point but got "X"}

test crimp-proj-transform-12.11 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{0 0} {0 0} X {0 0}}
} -returnCodes error -result {expected 2d point but got "X"}

test crimp-proj-transform-12.12 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{0 0} {0 0} {0 0} X}
} -returnCodes error -result {expected 2d point but got "X"}

test crimp-proj-transform-12.13 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{X 0} {0 0} {0 0} {0 0}} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.14 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 X} {0 0} {0 0} {0 0}} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.15 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {X 0} {0 0} {0 0}} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.16 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 X} {0 0} {0 0}} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.17 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {X 0} {0 0}} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.18 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 X} {0 0}} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.19 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {X 0}} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.20 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 X}} {{0 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.21 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{X 0} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.22 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{0 X} {0 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.23 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{0 0} {X 0} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.24 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{0 0} {0 X} {0 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.25 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{0 0} {0 0} {X 0} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.26 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{0 0} {0 0} {0 X} {0 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.27 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{0 0} {0 0} {0 0} {X 0}}
} -returnCodes error -result {expected floating-point number but got "X"}

test crimp-proj-transform-12.28 {projective transforms, quadrilateral, invalid arguments} -body {
    crimp transform quadrilateral {{0 0} {0 0} {0 0} {0 0}} {{0 0} {0 0} {0 0} {0 X}}
} -returnCodes error -result {expected floating-point number but got "X"}

# -------------------------------------------------------------------------
## Quadrilateral mappings representing various simple transformations, i.e.
## identity, translation, scaling, rotation, shear, and reflection.
## DONE      DONE         DONE               DONE

test crimp-proj-transform-12.29 {projective transforms, quadrilateral, identity} -body {
    decode_transform \
        [crimp transform quadrilateral \
             {{0 0} {1 0} {1 1} {0 1}} \
             {{0 0} {1 0} {1 1} {0 1}}]
} -match 4digits -result {
    1 0 0
    0 1 0
    0 0 1
}

test crimp-proj-transform-12.30 {projective transforms, quadrilateral, translation x} -body {
    decode_transform \
        [crimp transform quadrilateral \
             {{0 0} {1 0} {1 1} {0 1}} \
             {{5 0} {6 0} {6 1} {5 1}}]
} -match 4digits -result {
    1 0 5
    0 1 0
    0 0 1
}

test crimp-proj-transform-12.31 {projective transforms, quadrilateral, translation y} -body {
    decode_transform \
        [crimp transform quadrilateral \
             {{0 0} {1 0} {1 1} {0 1}} \
             {{0 6} {1 6} {1 7} {0 7}}]
} -match 4digits -result {
    1 0 0
    0 1 6
    0 0 1
}

test crimp-proj-transform-12.32 {projective transforms, quadrilateral, scale x} -body {
    decode_transform \
        [crimp transform quadrilateral \
             {{0 0} {1 0} {1 1} {0 1}} \
             {{0 0} {4 0} {4 1} {0 1}}]
} -match 4digits -result {
    4 0 0
    0 1 0
    0 0 1
}

test crimp-proj-transform-12.33 {projective transforms, quadrilateral, scale y} -body {
    decode_transform \
        [crimp transform quadrilateral \
             {{0 0} {1 0} {1 1} {0 1}} \
             {{0 0} {1 0} {1 5} {0 5}}]
} -match 4digits -result {
    1 0 0
    0 5 0
    0 0 1
}

test crimp-proj-transform-12.34 {projective transforms, quadrilateral, shear x} -body {
    decode_transform \
        [crimp transform quadrilateral \
             {{0 0} {1 0} {1 1} {0 1}} \
             {{0 0} {1 0} {2 1} {1 1}}]
} -match 4digits -result {
    1 1 0
    0 1 0
    0 0 1
}

test crimp-proj-transform-12.35 {projective transforms, quadrilateral, shear y} -body {
    decode_transform \
        [crimp transform quadrilateral \
             {{0 0} {1 0} {1 1} {0 1}} \
             {{0 0} {1 1} {1 2} {0 1}}]
} -match 4digits -result {
    1 0 0
    1 1 0
    0 0 1
}

# -------------------------------------------------------------------------

test crimp-proj-transform-12.38 {projective transforms, quadrilateral, general} -body {
    decode_transform \
        [crimp transform quadrilateral \
             {{0 0} {15 5} {30 30} {5 15}} \
             {{0 0} {40 0} {40 40} {0 40}}]
} -match 4digits -result {
    24      -8    0
    -1.3333  4    0
     0.5167 -0.15 1
}

test crimp-proj-transform-12.39 {projective transforms, quadrilateral, general inverse} -body {
    decode_transform \
        [crimp transform quadrilateral \
             {{0 0} {40 0} {40 40} {0 40}} \
             {{0 0} {15 5} {30 30} {5 15}}]
} -match 4digits -result {
     0.0469  0.0938 0
     0.0156  0.2813 0
    -0.0219 -0.0063 1
}

test crimp-proj-transform-12.40 {projective transforms, quadrilateral, inverse yield identity} -body {
    decode_transform \
        [crimp transform chain \
             [crimp transform quadrilateral \
                  {{0 0} {15 5} {30 30} {5 15}} \
                  {{0 0} {40 0} {40 40} {0 40}}] \
             [crimp transform quadrilateral \
                  {{0 0} {40 0} {40 40} {0 40}} \
                  {{0 0} {15 5} {30 30} {5 15}}]]
    # inverse mappings yield back identity.
} -match 4digits -result {
    1 0 0
    0 1 0
    0 0 1
}

# -------------------------------------------------------------------------
## Whitebox testing, internals of the quadrilateral: Q2UNIT.
## Calculate various simple affine transforms. See also 12.29+

test crimp-proj-transform-12.50 {projective transforms, quadrilateral core, identity} -body {
    decode_transform \
        [crimp::transform::Q2UNIT \
             {{0 0} {1 0} {1 1} {0 1}}]
} -match 4digits -result {
    1 0 0
    0 1 0
    0 0 1
}

test crimp-proj-transform-12.51 {projective transforms, quadrilateral core, translation x} -body {
    decode_transform \
        [crimp::transform::Q2UNIT \
             {{5 0} {6 0} {6 1} {5 1}}]
} -match 4digits -result {
    1 0 5
    0 1 0
    0 0 1
}

test crimp-proj-transform-12.52 {projective transforms, quadrilateral core, translation y} -body {
    decode_transform \
        [crimp::transform::Q2UNIT \
             {{0 6} {1 6} {1 7} {0 7}}]
} -match 4digits -result {
    1 0 0
    0 1 6
    0 0 1
}

test crimp-proj-transform-12.53 {projective transforms, quadrilateral core, scale x} -body {
    decode_transform \
        [crimp::transform::Q2UNIT \
             {{0 0} {4 0} {4 1} {0 1}}]
} -match 4digits -result {
    4 0 0
    0 1 0
    0 0 1
}

test crimp-proj-transform-12.54 {projective transforms, quadrilateral core, scale y} -body {
    decode_transform \
        [crimp::transform::Q2UNIT \
             {{0 0} {1 0} {1 5} {0 5}}]
} -match 4digits -result {
    1 0 0
    0 5 0
    0 0 1
}

test crimp-proj-transform-12.55 {projective transforms, quadrilateral core, shear x} -body {
    decode_transform \
        [crimp::transform::Q2UNIT \
             {{0 0} {1 0} {2 1} {1 1}}]
} -match 4digits -result {
    1 1 0
    0 1 0
    0 0 1
}

test crimp-proj-transform-12.56 {projective transforms, quadrilateral core, shear y} -body {
    decode_transform \
        [crimp::transform::Q2UNIT \
             {{0 0} {1 1} {1 2} {0 1}}]
} -match 4digits -result {
    1 0 0
    1 1 0
    0 0 1
}

# -------------------------------------------------------------------------
## Whitebox testing, internals of the quadrilateral: Q2UNIT.
## Computes transform from the unit rectangle to the given input corners.
## Just randomized testing.

# TODO: Re-enable. Test various forms of quadrilaterals...

apply {{} { return
    set n 0
    foreach _ [iota 500] {
        lassign [a-box] a b c d

        test crimp-proj-transform-12.60.$n "projective transforms, quadrilateral core, fuzz" -setup {
            set t [crimp::transform::Q2UNIT [list $a $b $c $d]]
        } -body {
            # Flatten the 4 result points into single list.
            join [crimp warp point $t {0 0} {1 0} {1 1} {0 1}]
        } -cleanup {
            unset t
        } -result [join [list $a $b $c $d]] -match 4digits

        incr n
    }
}}

# -------------------------------------------------------------------------

test crimp-proj-transform-13.0 {projective transforms, chain, wrong\#args, not enough} -body {
    crimp transform chain
} -returnCodes error -result {wrong # args: should be "crimp transform chain t ..."}

test crimp-proj-transform-13.1 {projective transforms, chain, invalid arguments} -body {
    crimp transform chain T
} -returnCodes error -result {expected projective transform but got "T"}

test crimp-proj-transform-13.2 {projective transforms, chain, single} -body {
    decode_transform \
        [crimp transform chain \
             [crimp transform projective 2 3 4 5 6 7 8 9]]
} -match 4digits -result {
    2 3 4
    5 6 7
    8 9 1
}

test crimp-proj-transform-13.3 {projective transforms, chain, single} -body {
    decode_transform \
        [crimp transform chain \
             [crimp transform rotate 2]]
} -match 4digits -result {
     0.9994  0.0349  0
    -0.0349  0.9994  0
     0.0000  0.0000  1
}

test crimp-proj-transform-13.4 {projective transforms, chain, translations} -body {
    decode_transform \
        [crimp transform chain \
                  [crimp transform translate 10 10] \
                  [crimp transform translate 50 50]]
} -match 4digits -result {
    1 0 60
    0 1 60
    0 0  1
}

test crimp-proj-transform-13.5 {projective transforms, chain, translate+rotate} -body {
    decode_transform \
        [crimp transform chain \
             [crimp transform rotate 2] \
             [crimp transform translate 50 50]]
} -match 4digits -result {
     0.9994 0.0349 50.0000
    -0.0349 0.9994 50.0000
     0.0000 0.0000 1.0000
}

test crimp-proj-transform-13.6 {projective transforms, chain, rotate+translate} -body {
    decode_transform \
        [crimp transform chain \
             [crimp transform translate 50 50] \
             [crimp transform rotate 2]]
} -match 4digits -result {
     0.9994 0.0349 51.7145
    -0.0349 0.9994 48.2246
     0.0000 0.0000  1.0000
}

test crimp-proj-transform-13.7 {projective transforms, chain, translated rotation} -body {
    decode_transform \
        [crimp transform chain \
             [crimp transform translate -50 -50] \
             [crimp transform rotate 2] \
             [crimp transform translate 50 50]]
} -match 4digits -result {
     0.9994  0.0349 -1.7145
    -0.0349  0.9994  1.7754
     0.0000  0.0000  1.0000
}

# -------------------------------------------------------------------------

test crimp-proj-transform-14.0 {projective transforms, invert, wrong\#args, not enough} -body {
    crimp transform invert
} -returnCodes error -result {wrong # args: should be "crimp transform invert a"}

test crimp-proj-transform-14.1 {projective transforms, invert, wrong\#args, too many} -body {
    crimp transform invert A toomuch
} -returnCodes error -result {wrong # args: should be "crimp transform invert a"}

test crimp-proj-transform-14.2 {projective transforms, invert, invalid arguments} -body {
    crimp transform invert A
} -returnCodes error -result {expected projective transform but got "A"}

test crimp-proj-transform-14.3 {projective transforms, invert, identity} -body {
    decode_transform \
        [crimp transform invert \
             [crimp transform identity]]
} -match 4digits -result {
    1 0 0
    0 1 0
    0 0 1
}

test crimp-proj-transform-14.4 {projective transforms, invert, rotate} -body {
    decode_transform \
        [crimp transform invert \
             [crimp transform rotate -2]]
    # inverse of 'rotate -2' is 'rotate 2'.
} -match 4digits -result {
     0.9994 0.0349 0
    -0.0349 0.9994 0
     0.0000 0.0000 1
}

# -------------------------------------------------------------------------

test crimp-proj-transform-15.0 {projective transforms, identity, wrong\#args, too many} -body {
    crimp transform identity toomuch
} -returnCodes error -result {wrong # args: should be "crimp transform identity"}

test crimp-proj-transform-15.1 {projective transforms, identity} -body {
    decode_transform \
        [crimp transform identity]
} -match 4digits -result {
    1 0 0
    0 1 0
    0 0 1
}

# No randomized testing of this one, trivial.

# -------------------------------------------------------------------------
testsuiteCleanup

# Local variables:
# mode: tcl
# indent-tabs-mode: nil
# End:
