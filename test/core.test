# add.test -*- tcl -*-
# -------------------------------------------------------------------------

source [file join \
            [file dirname [file join [pwd] [info script]]] \
            testutilities.tcl]

testsNeedTcl     8.5
testsNeedTcltest 2

support {}
testing {
    useC [mainPath _test/lib]/crimp_core* crimp::core no
}

proc empty {}     { crimp read tcl grey8 {} }
proc emeta {dict} { crimp meta create [empty] {*}$dict }

# -------------------------------------------------------------------------
## Core manipulation: Conversion between images and Tcl data structures.
## Note: If these do not work all other tests won't either, as they
## all require some way of creating inputs and inspecting results.

test crimp-core-1.0 {Basic conversion from Tcl and back, integer} -body {
    set image [crimp read tcl grey8 {{1 2} {3 4}}]
    crimp write 2string tcl $image
} -cleanup {
    unset image
} -result {{1 2} {3 4}}

test crimp-core-1.1 {Basic conversion from Tcl and back, floating point} -body {
    set image [crimp read tcl float {{1 2} {3 4}}]
    crimp write 2string tcl $image
} -cleanup {
    unset image
} -result {{1.0 2.0} {3.0 4.0}}

test crimp-core-1.2 {Basic conversion from Tcl and back, empty image} -body {
    set image [crimp read tcl grey8 {}]
    crimp write 2string tcl $image
} -cleanup {
    unset image
} -result {}

test crimp-core-1.3 {Basic conversion from Tcl and back, empty image, single-row} -body {
    set image [crimp read tcl grey8 {{}}]
    crimp write 2string tcl $image
} -cleanup {
    unset image
} -result {}

# -------------------------------------------------------------------------
## Testing the core accessors: Geometry, type and channel information (names)

foreach {accessor result} {
    geometry   {0 0 2 2}
    at         {0 0}
    dimensions {2 2}
    x          0
    y          0
    width      2
    height     2
    type       crimp::image::grey8
    channels   luma
} {
    test crimp-core-${accessor}-1.0 "Accessors: $accessor, wrong\#args, not enough" -body {
        crimp $accessor
    } -returnCodes error -result "wrong \# args: should be \"crimp $accessor imageObj\""

    test crimp-core-${accessor}-1.1 "Accessors: $accessor, wrong\#args, too many" -body {
        crimp $accessor IMAGE toomuch
    } -returnCodes error -result "wrong \# args: should be \"crimp $accessor imageObj\""

    test crimp-core-${accessor}-1.2 "Accessors: $accessor" -setup {
        set image [crimp read tcl grey8 {{1 2} {3 4}}]
    } -body {
        crimp $accessor $image
    } -cleanup {
        unset image
    } -result $result
}

# -------------------------------------------------------------------------
## Testing the core accessors: Raw pixels (ByteArray)

test crimp-core-pixel-1.0 "Accessors: pixel, wrong\#args, not enough" -body {
    crimp pixel
} -returnCodes error -result "wrong \# args: should be \"crimp pixel imageObj\""

test crimp-core-pixel-1.1 "Accessors: pixel, wrong\#args, too many" -body {
    crimp pixel IMAGE toomuch
} -returnCodes error -result "wrong \# args: should be \"crimp pixel imageObj\""

test crimp-core-pixel-1.2 "Accessors: pixel" -setup {
    set image [crimp read tcl grey8 {{1 2} {3 4}}]
} -body {
    list [binary scan [crimp pixel $image] H* image] $image
} -cleanup {
    unset image
} -result {1 01020304}

# -------------------------------------------------------------------------
## Core image types, i.e. types the core can create ...

foreach {n cando itype channels} {
    0 {}     grey8     {luma}
    1   NYI  grey16    {luma}
    2   NYI  grey32    {luma}
    3 {}     float     {value}
    4   NYI  fpcomplex {real imaginary}
    5   NYI  rgb       {red green blue}
    6   NYI  rgba      {red green blue alpha}
    7   NYI  hsv       {hue saturation value}
} {
    test crimp-core-type-2.$n {Accessors: type} -setup {
        set image [crimp read tcl $itype {{1 2} {3 4}}]
    } -body {
        crimp type $image
    } -cleanup {
        unset image
    } -result crimp::image::$itype -constraints $cando

    test crimp-core-channels-2.$n {Accessors: channel names} -setup {
        set image [crimp read tcl $itype {{1 2} {3 4}}]
    } -body {
        crimp channels $image
    } -cleanup {
        unset image
    } -result $channels -constraints $cando
}

# -------------------------------------------------------------------------
## Testing the core accessors: Low level access to the image meta data.

test crimp-core-meta-1.0 {Accessor, meta_get, wrong\#args, not enough} -body {
    crimp::C::meta_get
} -returnCodes error -result {wrong # args: should be "crimp::C::meta_get imageObj"}

test crimp-core-meta-1.1 {Accessor, meta_get, wrong\#args, too many} -body {
    crimp::C::meta_get IMAGE toomuch
} -returnCodes error -result {wrong # args: should be "crimp::C::meta_get imageObj"}

test crimp-core-meta-1.2 {Accessor, meta_get, default} -setup {
    set image [empty]
} -body {
    crimp::C::meta_get $image
} -cleanup {
    unset image
} -result {}

test crimp-core-meta-2.0 {Accessor, meta_set, wrong\#args, not enough} -body {
    crimp::C::meta_set
} -returnCodes error -result {wrong # args: should be "crimp::C::meta_set imageObj metaObj"}

test crimp-core-meta-2.1 {Accessor, meta_set, wrong\#args, not enough} -body {
    crimp::C::meta_set IMAGE
} -returnCodes error -result {wrong # args: should be "crimp::C::meta_set imageObj metaObj"}

test crimp-core-meta-2.2 {Accessor, meta_set, wrong\#args, too many} -body {
    crimp::C::meta_set IMAGE VALUE toomuch
} -returnCodes error -result {wrong # args: should be "crimp::C::meta_set imageObj metaObj"}

test crimp-core-meta-2.3 {Accessor, meta_set + meta_get} -setup {
    set image [empty]
} -body {
    crimp::C::meta_get [crimp::C::meta_set $image META]
} -cleanup {
    unset image
} -result META

# -------------------------------------------------------------------------
## Testing the core accessors: High level access to the image meta data.
## Dictionary methods -- See to snarfing the tests from the Tcl core.

## TODO

test crimp-meta-1.0 {Accessor: meta command basic syntax} -returnCodes error -body {
    crimp meta
} -result {wrong # args: should be "crimp meta cmd image ..."}

test crimp-meta-1.1 {Accessor: meta command basic syntax} -returnCodes error -body {
    crimp meta CMD
} -result {wrong # args: should be "crimp meta cmd image ..."}

test crimp-meta-1.2 {Accessor: meta command basic syntax} -returnCodes error -body {
    crimp meta ? IMAGE
} -match glob -result {Unknown method "?", expected one of append, create, exists, filter, for, get, incr, info, keys, lappend, merge, remove, replace, set, size, unset, or values}


test crimp-meta-2.0 {Accessor: meta create command, wrong#args} -returnCodes error -body {
    crimp meta create [empty] a
} -result {wrong # args: should be "dict create ?key value ...?"}

test crimp-meta-2.1 {Accessor: meta create command, wrong#args} -returnCodes error -body {
    crimp meta create [empty] a b c
} -result {wrong # args: should be "dict create ?key value ...?"}

test crimp-meta-2.2 {Accessor: meta create command} -body {
    crimp meta create [empty]
} -result {crimp::image::grey8 0 0 {} {}}

test crimp-meta-2.3 {Accessor: meta create command} -body {
    crimp meta create [empty] a b
} -result {crimp::image::grey8 0 0 {a b} {}}

test crimp-meta-3.1 {Accessor: meta get command} {
    crimp meta get [emeta {a b}] a
} b

test crimp-meta-3.2 {Accessor: meta get command} {
    crimp meta get [emeta {a b c d}] a
} b

test crimp-meta-3.3 {Accessor: meta get command} {
    crimp meta get [emeta {a b c d}] c
} d

test crimp-meta-3.4 {Accessor: meta get command} -returnCodes error -body {
    crimp meta get [emeta {a b c d}] b
} -result {key "b" not known in dictionary}

test crimp-meta-3.5 {Accessor: meta get command} {
    crimp meta get [emeta {a b}]
} {a b}


test crimp-meta-4.1 {Accessor: meta replace command} {
    crimp meta get [crimp meta replace [emeta {a b c d}]]
} {a b c d}

test crimp-meta-4.2 {Accessor: meta replace command} {
    crimp meta get [crimp meta replace [emeta {a b c d}] e f]
} {a b c d e f}

test crimp-meta-4.3 {Accessor: meta replace command} {
    crimp meta get [crimp meta replace [emeta {a b c d}] c f]
} {a b c f}

test crimp-meta-4.4 {Accessor: meta replace command} {
    crimp meta get [crimp meta replace [emeta {a b c d}] c x a y]
} {a y c x}


test crimp-meta-5.1 {Accessor: meta remove command} {
    crimp meta get [crimp meta remove [emeta {a b c d}] a]
} {c d}

test crimp-meta-5.2 {Accessor: meta remove command} {
    crimp meta get [crimp meta remove [emeta {a b c d}] c]
} {a b}

test crimp-meta-5.3 {Accessor: meta remove command} {
    crimp meta get [crimp meta remove [emeta {a b c d}] a c]
} {}

test crimp-meta-5.4 {Accessor: meta remove command} {
    crimp meta get [crimp meta remove [emeta {a b c d}] c a]
} {}

test crimp-meta-5.5 {Accessor: meta remove command} {
    crimp meta get [crimp meta remove [emeta {a b c d}]]
} {a b c d}

test crimp-meta-5.6 {Accessor: meta remove command} {
    crimp meta get [crimp meta remove [emeta {a b}] c]
} {a b}



# -------------------------------------------------------------------------
## Testing the core accessors: Placement.

test crimp-core-place-1.0 "Accessors: place, wrong\#args, not enough" -body {
    crimp place
} -returnCodes error -result "wrong \# args: should be \"crimp place imageObj x y\""

test crimp-core-place-1.1 "Accessors: place, wrong\#args, not enough" -body {
    crimp place IMAGE
} -returnCodes error -result "wrong \# args: should be \"crimp place imageObj x y\""

test crimp-core-place-1.2 "Accessors: place, wrong\#args, not enough" -body {
    crimp place IMAGE x
} -returnCodes error -result "wrong \# args: should be \"crimp place imageObj x y\""

test crimp-core-place-1.3 "Accessors: place, wrong\#args, too many" -body {
    crimp place IMAGE x y toomuch
} -returnCodes error -result "wrong \# args: should be \"crimp place imageObj x y\""

test crimp-core-place-1.4 "Accessors: place" -setup {
    set image [crimp read tcl grey8 {{1 2} {3 4}}]
} -body {
    crimp at [crimp place $image -2 5]
} -cleanup {
    unset image
} -result {-2 5}

# -------------------------------------------------------------------------

test crimp-core-bbox2-1.0 {bbox2, wrong#args, not enough} -body {
    crimp bbox2
} -returnCodes error -result {wrong # args: should be "crimp bbox2 ax ay aw ah bx by bw bh"}

test crimp-core-bbox2-1.1 {bbox2, wrong#args, not enough} -body {
    crimp bbox2 ax
} -returnCodes error -result {wrong # args: should be "crimp bbox2 ax ay aw ah bx by bw bh"}

test crimp-core-bbox2-1.2 {bbox2, wrong#args, not enough} -body {
    crimp bbox2 ax ay
} -returnCodes error -result {wrong # args: should be "crimp bbox2 ax ay aw ah bx by bw bh"}

test crimp-core-bbox2-1.3 {bbox2, wrong#args, not enough} -body {
    crimp bbox2 ax ay aw
} -returnCodes error -result {wrong # args: should be "crimp bbox2 ax ay aw ah bx by bw bh"}

test crimp-core-bbox2-1.4 {bbox2, wrong#args, not enough} -body {
    crimp bbox2 ax ay aw ah
} -returnCodes error -result {wrong # args: should be "crimp bbox2 ax ay aw ah bx by bw bh"}

test crimp-core-bbox2-1.5 {bbox2, wrong#args, not enough} -body {
    crimp bbox2 ax ay aw ah bx
} -returnCodes error -result {wrong # args: should be "crimp bbox2 ax ay aw ah bx by bw bh"}

test crimp-core-bbox2-1.6 {bbox2, wrong#args, not enough} -body {
    crimp bbox2 ax ay aw ah bx by
} -returnCodes error -result {wrong # args: should be "crimp bbox2 ax ay aw ah bx by bw bh"}

test crimp-core-bbox2-1.7 {bbox2, wrong#args, not enough} -body {
    crimp bbox2 ax ay aw ah bx by bw
} -returnCodes error -result {wrong # args: should be "crimp bbox2 ax ay aw ah bx by bw bh"}

test crimp-core-bbox2-1.8 {bbox2, wrong#args, too many} -body {
    crimp bbox2 ax ay aw ah bx by bw bh toomuch
} -returnCodes error -result {wrong # args: should be "crimp bbox2 ax ay aw ah bx by bw bh"}

set bboxexamples {
    0 {0 0 0 0} {0 0 0 0} {0 0 0 0}
    1 {0 0 0 0} {1 1 0 0} {0 0 1 1}
    2 {0 0 2 2} {1 1 2 2} {0 0 3 3}
    3 {0 0 2 2} {1 -1 2 2} {0 -1 3 3}
    4 {0 0 2 2} {-1 1 2 2} {-1 0 3 3}
    5 {0 0 5 5} {1 1 3 3} {0 0 5 5}
    6 {0 0 5 5} {-1 1 3 3} {-1 0 6 5}
    7 {0 0 5 5} {3 1 3 3} {0 0 6 5}
    6 {0 0 5 5} {-1 1 7 3} {-1 0 7 5}
}

foreach {n a b r} $bboxexamples {
    test crimp-core-bbox2-2.$n {bbox2} -body {
        crimp bbox2 {*}$a {*}$b
    } -result $r

    test crimp-core-bbox2-3.$n {bbox2} -body {
        crimp bbox2 {*}$b {*}$a
    } -result $r
}

# -------------------------------------------------------------------------

test crimp-core-bbox-1.0 {bbox, wrong#args, not enough} -body {
    crimp bbox
} -returnCodes error -result {wrong # args: should be "crimp bbox head ..."}

test crimp-core-bbox-1.0 {bbox, wrong#args, not enough} -body {
    crimp bbox
} -returnCodes error -result {wrong # args: should be "crimp bbox head ..."}

foreach {n a b r} $bboxexamples {
    lassign $a x y w h
    set imagea [crimp place \
                    [crimp read tcl grey8 \
                         [expr { $w
                                 ? [lrepeat $h [lrepeat $w 0]]
                                 : {}
                             }]] $x $y]
    
    lassign $b x y w h
    set imageb [crimp place \
                    [crimp read tcl grey8 \
                         [expr { $w
                                 ? [lrepeat $h [lrepeat $w 0]]
                                 : {}
                             }]] $x $y]
    unset x y w h

    test crimp-core-bbox-2.$n {bbox} -body {
        crimp bbox $imagea $imageb
    } -result $r

    test crimp-core-bbox-3.$n {bbox} -body {
        crimp bbox $imageb $imagea
    } -result $r

    unset imagea imageb
}

# -------------------------------------------------------------------------
## Writing of various image types to tcl format, all possible types of
## destinations.

## TODO :: write types -> tcl: rgb, rgba, hsv, fpcomplex

foreach {n cando itype data result} {
    0 {}     grey8     {{1 2} {3 4}} {{1 2} {3 4}}
    1 {}     grey16    {{1 2} {3 4}} {{1 2} {3 4}}
    2 {}     grey32    {{1 2} {3 4}} {{1 2} {3 4}}
    3 {}     float     {{1 2} {3 4}} {{1.0 2.0} {3.0 4.0}}
    4   NYI  fpcomplex {} {}
    5   NYI  rgb       {} {}
    6   NYI  rgba      {} {}
    7   NYI  hsv       {} {}
} {
    test crimp-core-write-${itype}-1.0 "write tcl, $itype 2string" -setup {
        set image [crimp read tcl $itype $data]
    } -body {
        crimp write 2string tcl $image
    } -cleanup {
        unset image
    } -result $result -constraints $cando

    test crimp-core-write-${itype}-1.1 "write tcl, $itype 2chan" -setup {
        set temp [tempPath CHAN]
        set image [crimp read tcl $itype $data]
    } -body {
        set c [open $temp w]
        crimp write 2chan tcl $c $image
        close $c
        viewFile $temp
    } -cleanup {
        file delete $temp
        unset image
    } -result $result -constraints $cando

    test crimp-core-write-${itype}-1.2 "write tcl, $itype 2file" -setup {
        set temp [tempPath CHAN]
        set image [crimp read tcl $itype $data]
    } -body {
        crimp write 2file tcl $temp $image
        viewFile $temp
    } -cleanup {
        file delete $temp
        unset image
    } -result $result -constraints $cando
}

# -------------------------------------------------------------------------

rename emeta {}
rename empty {}
unset bboxexamples
testsuiteCleanup

# Local variables:
# mode: tcl
# indent-tabs-mode: nil
# End:
