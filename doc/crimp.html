
<html><head>
<title>crimp - Image Manipulation</title>
<style type="text/css"><!--
    HTML {
	background: 	#FFFFFF;
	color: 		black;
    }
    BODY {
	background: 	#FFFFFF;
	color:	 	black;
    }
    DIV.doctools {
	margin-left:	10%;
	margin-right:	10%;
    }
    DIV.doctools H1,DIV.doctools H2 {
	margin-left:	-5%;
    }
    H1, H2, H3, H4 {
	margin-top: 	1em;
	font-family:	sans-serif;
	font-size:	large;
	color:		#005A9C;
	background: 	transparent;
	text-align:		left;
    }
    H1.title {
	text-align: center;
    }
    UL,OL {
	margin-right: 0em;
	margin-top: 3pt;
	margin-bottom: 3pt;
    }
    UL LI {
	list-style: disc;
    }
    OL LI {
	list-style: decimal;
    }
    DT {
	padding-top: 	1ex;
    }
    UL.toc,UL.toc UL, UL.toc UL UL {
	font:		normal 12pt/14pt sans-serif;
	list-style:	none;
    }
    LI.section, LI.subsection {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding: 	0em;
    }
    PRE {
	display: 	block;
	font-family:	monospace;
	white-space:	pre;
	margin:		0%;
	padding-top:	0.5ex;
	padding-bottom:	0.5ex;
	padding-left:	1ex;
	padding-right:	1ex;
	width:		100%;
    }
    PRE.example {
	color: 		black;
	background: 	#f5dcb3;
	border:		1px solid black;
    }
    UL.requirements LI, UL.syntax LI {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding:	0em;
    }
    DIV.synopsis {
	color: 		black;
	background: 	#80ffff;
	border:		1px solid black;
	font-family:	serif;
	margin-top: 	1em;
	margin-bottom: 	1em;
    }
    UL.syntax {
	margin-top: 	1em;
	border-top:	1px solid black;
    }
    UL.requirements {
	margin-bottom: 	1em;
	border-bottom:	1px solid black;
    }
--></style>
</head>
<! -- Generated from file 'crimp.man' by tcllib/doctools with format 'html'
   -->
<! -- Copyright &copy; 2010 Andreas Kupries   -- Copyright &copy; 2010 Documentation, Andreas Kupries
   -->
<! -- CVS: $Id$ crimp.n
   -->
<body><div class="doctools">
<h1 class="title">crimp(n) 1.0.1 crimp &quot;Image Manipulation&quot;</h1>
<div id="name" class="section"><h2><a name="name">Name</a></h2>
<p>crimp - Image Manipulation (not yet independent of Tk)</p>
</div>
<div id="toc" class="section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="toc">
<li class="section"><a href="#toc">Table Of Contents</a></li>
<li class="section"><a href="#synopsis">Synopsis</a></li>
<li class="section"><a href="#section1">Description</a></li>
<li class="section"><a href="#section2">Images</a></li>
<li class="section"><a href="#section3">Image Types</a></li>
<li class="section"><a href="#section4">General design</a></li>
<li class="section"><a href="#section5">API</a>
<ul>
<li class="subsection"><a href="#subsection1">Accessors</a></li>
<li class="subsection"><a href="#subsection2">Manipulators</a></li>
<li class="subsection"><a href="#subsection3">Converters</a></li>
<li class="subsection"><a href="#subsection4">I/O commands</a></li>
<li class="subsection"><a href="#subsection5">Support</a></li>
</ul>
</li>
<li class="section"><a href="#keywords">Keywords</a></li>
<li class="section"><a href="#copyright">Copyright</a></li>
</ul>
</div>
<div id="synopsis" class="section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="synopsis">
<ul class="requirements">
<li>package require <b class="pkgname">Tcl 8.5</b></li>
<li>package require <b class="pkgname">Tk 8.5</b></li>
<li>package require <b class="pkgname">crimp <span class="opt">?1?</span></b></li>
</ul>
<ul class="syntax">
<li><a href="#1"><b class="cmd">::crimp</b> <b class="method">channels</b> <i class="arg">image</i></a></li>
<li><a href="#2"><b class="cmd">::crimp</b> <b class="method">dimensions</b> <i class="arg">image</i></a></li>
<li><a href="#3"><b class="cmd">::crimp</b> <b class="method">height</b> <i class="arg">image</i></a></li>
<li><a href="#4"><b class="cmd">::crimp</b> <b class="method">histogram</b> <i class="arg">image</i></a></li>
<li><a href="#5"><b class="cmd">::crimp</b> <b class="method">type</b> <i class="arg">image</i></a></li>
<li><a href="#6"><b class="cmd">::crimp</b> <b class="method">width</b> <i class="arg">image</i></a></li>
<li><a href="#7"><b class="cmd">::crimp</b> <b class="method">blank</b> <i class="arg">type</i> <i class="arg">width</i> <i class="arg">height</i> <i class="arg">value</i>...</a></li>
<li><a href="#8"><b class="cmd">::crimp</b> <b class="method">blend</b> <i class="arg">foreground</i> <i class="arg">background</i> <i class="arg">alpha</i></a></li>
<li><a href="#9"><b class="cmd">::crimp</b> <b class="method">degamma</b> <i class="arg">image</i> <i class="arg">y</i></a></li>
<li><a href="#10"><b class="cmd">::crimp</b> <b class="method">expand const</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i> <span class="opt">?<i class="arg">value</i>...?</span></a></li>
<li><a href="#11"><b class="cmd">::crimp</b> <b class="method">expand extend</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></li>
<li><a href="#12"><b class="cmd">::crimp</b> <b class="method">expand mirror</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></li>
<li><a href="#13"><b class="cmd">::crimp</b> <b class="method">expand replicate</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></li>
<li><a href="#14"><b class="cmd">::crimp</b> <b class="method">expand wrap</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></li>
<li><a href="#15"><b class="cmd">::crimp</b> <b class="method">gamma</b> <i class="arg">image</i> <i class="arg">y</i></a></li>
<li><a href="#16"><b class="cmd">::crimp</b> <b class="method">invert</b> <i class="arg">image</i></a></li>
<li><a href="#17"><b class="cmd">::crimp</b> <b class="method">matrix</b> <i class="arg">image</i> <i class="arg">matrix</i></a></li>
<li><a href="#18"><b class="cmd">::crimp</b> <b class="method">over</b> <i class="arg">foreground</i> <i class="arg">background</i></a></li>
<li><a href="#19"><b class="cmd">::crimp</b> <b class="method">psychedelia</b> <i class="arg">width</i> <i class="arg">height</i> <i class="arg">frames</i></a></li>
<li><a href="#20"><b class="cmd">::crimp</b> <b class="method">remap</b> <i class="arg">image</i> <i class="arg">map</i>...</a></li>
<li><a href="#21"><b class="cmd">::crimp</b> <b class="method">setalpha</b> <i class="arg">image</i> <i class="arg">mask</i></a></li>
<li><a href="#22"><b class="cmd">::crimp</b> <b class="method">solarize</b> <i class="arg">image</i> <i class="arg">threshold</i></a></li>
<li><a href="#23"><b class="cmd">::crimp</b> <b class="method">wavy</b> <i class="arg">image</i> <i class="arg">offset</i> <i class="arg">adj1</i> <i class="arg">adjb</i></a></li>
<li><a href="#24"><b class="cmd">::crimp</b> <b class="method">flip horizontal</b> <i class="arg">image</i></a></li>
<li><a href="#25"><b class="cmd">::crimp</b> <b class="method">flip transpose</b> <i class="arg">image</i></a></li>
<li><a href="#26"><b class="cmd">::crimp</b> <b class="method">flip transverse</b> <i class="arg">image</i></a></li>
<li><a href="#27"><b class="cmd">::crimp</b> <b class="method">flip vertical</b> <i class="arg">image</i></a></li>
<li><a href="#28"><b class="cmd">::crimp</b> <b class="method">convert 2grey8</b> <i class="arg">image</i></a></li>
<li><a href="#29"><b class="cmd">::crimp</b> <b class="method">convert 2hsv</b> <i class="arg">image</i></a></li>
<li><a href="#30"><b class="cmd">::crimp</b> <b class="method">convert 2rgba</b> <i class="arg">image</i></a></li>
<li><a href="#31"><b class="cmd">::crimp</b> <b class="method">convert 2rgb</b> <i class="arg">image</i></a></li>
<li><a href="#32"><b class="cmd">::crimp</b> <b class="method">join 2hsv</b> <i class="arg">hueImage</i> <i class="arg">satImage</i> <i class="arg">valImage</i></a></li>
<li><a href="#33"><b class="cmd">::crimp</b> <b class="method">join 2rgba</b> <i class="arg">redImage</i> <i class="arg">greenImage</i> <i class="arg">blueImage</i> <i class="arg">alphaImage</i></a></li>
<li><a href="#34"><b class="cmd">::crimp</b> <b class="method">join 2rgb</b> <i class="arg">redImage</i> <i class="arg">greenImage</i> <i class="arg">blueImage</i></a></li>
<li><a href="#35"><b class="cmd">::crimp</b> <b class="method">split</b> <i class="arg">image</i></a></li>
<li><a href="#36"><b class="cmd">::crimp</b> <b class="method">read tcl</b> <i class="arg">pixelmatrix</i></a></li>
<li><a href="#37"><b class="cmd">::crimp</b> <b class="method">read tk</b> <i class="arg">photo</i></a></li>
<li><a href="#38"><b class="cmd">::crimp</b> <b class="method">write 2tk</b> <i class="arg">photo</i> <i class="arg">image</i></a></li>
<li><a href="#39"><b class="cmd">::crimp</b> <b class="method">map</b> <i class="arg">arg</i>...</a></li>
<li><a href="#40"><b class="cmd">::crimp</b> <b class="method">table degamma</b> <i class="arg">y</i></a></li>
<li><a href="#41"><b class="cmd">::crimp</b> <b class="method">table gainw</b> <i class="arg">gain</i> <i class="arg">bias</i></a></li>
<li><a href="#42"><b class="cmd">::crimp</b> <b class="method">table gain</b> <i class="arg">gain</i> <i class="arg">bias</i></a></li>
<li><a href="#43"><b class="cmd">::crimp</b> <b class="method">table gamma</b> <i class="arg">y</i></a></li>
<li><a href="#44"><b class="cmd">::crimp</b> <b class="method">table identity</b></a></li>
<li><a href="#45"><b class="cmd">::crimp</b> <b class="method">table invers</b></a></li>
<li><a href="#46"><b class="cmd">::crimp</b> <b class="method">table solarize</b> <i class="arg">threshold</i></a></li>
</ul>
</div>
</div>
<div id="section1" class="section"><h2><a name="section1">Description</a></h2>
<p>This package provides image manipulation commands which are mostly
independent of Tk. The only parts currently depending on Tk are for
the import and export of images from and to Tk photos, necessary for
display.</p>
<p>Note that the intended audience of this document are the users of
<b class="package">crimp</b>. Developers wishing to work on the internals of the
package, but unfamiliar with them, should read ... instead.</p>
</div>
<div id="section2" class="section"><h2><a name="section2">Images</a></h2>
<p>Images are values. This means that they have a string
representation. It is however strongly recommended to not access this
representation at all, and to only use the accessor commands provided
by crimp to obtain the information stored in the internal
representation of image values.</p>
<p>The reason behind this is simple: Memory and speed. Images can be
large. Generating the string representation from the internal one
roughly doubles the memory needed to store it, actually a bit more,
due to the necessary quoting of bytes in UTF-8 and list-quting them as
well. Furthermore such a conversion takes time, roughly proportional
to the size of the image itself, in either direction. Properly
accessing the image information without the package's accessor
commands requires list commands. This causes the loss of the internal
representation, thus forcing later a reconversion to the image's
internal represention when it is used as image again. I.e. the
shimmering forces us to convert twice.</p>
<p>Therefore, avoid this, use only the crimp commands to access the
images. The only part of them you are not able to access through these
is the pixel data. And requiring access to that in a Tcl script is,
IMHO, highly unusual. In such a situation it is likely better and
easier to simply become a developer and extend the C level parts of
crimp with the operation which would have required that access.</p>
</div>
<div id="section3" class="section"><h2><a name="section3">Image Types</a></h2>
<p>Each image has a <i class="term">type</i>, a string implicitly describing features
like the colorspace the image is in, the number of (color) channels,
the domain, i.e. bit-depth, of pixel values in the channels, etc.</p>
<p>All type strings have the form <b class="const">crimp::image::</b><b class="variable">foo</b>.</p>
<p>The package currently knows the following types:</p>
<dl class="definitions">
<dt><b class="const">rgba</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>RGB also known as Red, Green, and Blue.</p></dd>
<dt>Channels</dt>
<dd><p>4, named &quot;red&quot;, &quot;green&quot;, and &quot;blue&quot;,
				plus an &quot;alpha&quot; channel controlling
				pixel opacity.</p></dd>
<dt>Bit-depth</dt>
<dd><p>1 byte/channel (8 bit, values 0-255).</p></dd>
<dt>Pixel-size</dt>
<dd><p>4 bytes.</p></dd>
</dl></dd>
<dt><b class="const">rgb</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>RGB also known as Red, Green, and Blue.</p></dd>
<dt>Channels</dt>
<dd><p>3, named &quot;red&quot;, &quot;green&quot;, and &quot;blue&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>1 byte/channel (8 bit, values 0-255).</p></dd>
<dt>Pixel-size</dt>
<dd><p>3 bytes.</p></dd>
</dl></dd>
<dt><b class="const">hsv</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>HSV, also known as Hue, Saturation, and Value.</p></dd>
<dt>Channels</dt>
<dd><p>3, named &quot;hue&quot;, &quot;saturation&quot;, and &quot;value&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>1 byte/channel (8 bit, values 0-255).</p></dd>
<dt>Pixel-size</dt>
<dd><p>3 bytes.</p></dd>
</dl></dd>
<dt><b class="const">grey8</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>Greyscale.</p></dd>
<dt>Channels</dt>
<dd><p>1, named &quot;luma&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>1 byte/channel (8 bit, values 0-255).</p></dd>
<dt>Pixel-size</dt>
<dd><p>1 byte.</p></dd>
</dl></dd>
<dt><b class="const">grey16</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>Greyscale.</p></dd>
<dt>Channels</dt>
<dd><p>1, named &quot;luma&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>2 byte/channel (16 bit, values 0-65,535).</p></dd>
<dt>Pixel-size</dt>
<dd><p>2 bytes.</p></dd>
</dl></dd>
<dt><b class="const">grey32</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>Greyscale.</p></dd>
<dt>Channels</dt>
<dd><p>1, named &quot;luma&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>4 byte/channel (16 bit, values 0-4,294,967,296).</p></dd>
<dt>Pixel-size</dt>
<dd><p>4 bytes.</p></dd>
</dl></dd>
<dt><b class="const">bw</b></dt>
<dd><dl class="definitions">
	
<dt>Colorspace</dt>
<dd><p>Binary.</p></dd>
<dt>Channels</dt>
<dd><p>1, named &quot;bw&quot;.</p></dd>
<dt>Bit-depth</dt>
<dd><p>1 bit/channel.</p></dd>
<dt>Pixel-size</dt>
<dd><p>1 byte. I.e. 7 bits/channel are wasted.</p></dd>
</dl></dd>
</dl>
<p>Support for the various types varies by operation. The exact image
types supported by each operation are listed the operation's
description. Invoking an operation for a type it doesn't support will
generally cause it to throw an error.</p>
</div>
<div id="section4" class="section"><h2><a name="section4">General design</a></h2>
<p>All commands operate in a pipeline fashion, taking zero or more image
values, zero or more other arguments, and returning zero or more
images or other values. None are operating in place, i.e. taking an
image variable and writing back to it.</p>
<p>They fall, into five categories, namely:</p>
<dl class="definitions">
<dt>Accessors</dt>
<dd><p>They take one or more images, extract information about them, and
return this information as their result. This can be a simple as
querying the image's height, to something as complex as counting pixel
values for a histogram.</p>
<p>The list of accessors, their syntax, and detailed meaning can be found
in section <span class="sectref"><a href="#subsection1">Accessors</a></span>.</p></dd>
<dt>Manipulators</dt>
<dd><p>These take an image and transform its contents in some way, leaving
the image type unchanged. Examples of commands in category are
inversion, gamma conversion, etc.</p>
<p>The list of manipulators, their syntax, and detailed meaning can be
found in section <span class="sectref"><a href="#subsection2">Manipulators</a></span>.</p></dd>
<dt>Converters</dt>
<dd><p>Similar to manipulators, except that they change the image's type,
preserving the content instead. Here reside operations like conversion
between the HSV and RGB colorspaces, to greyscale and back, etc.</p>
<p>The list of converters, their syntax, and detailed meaning can be
found in section <span class="sectref"><a href="#subsection3">Converters</a></span>.</p></dd>
<dt>I/O</dt>
<dd><p>Another variant of the same theme, i.e. akin to converters and
manipulators, yet not the same, these commands read and write images
from and to files or other data structures. I.e. they convert between
different serializations of image content and type.</p>
<p>The list of I/O commands, their syntax, and detailed meaning can be
found in section <span class="sectref"><a href="#subsection4">I/O commands</a></span>.</p></dd>
<dt>Support</dt>
<dd><p>Lastly, but not leastly a number of commands, which, while not image
commands themselves, support the others.</p>
<p>The list of supporting commands, their syntax, and detailed meaning
can be found in section <span class="sectref"><a href="#subsection5">Support</a></span>.</p></dd>
</dl>
</div>
<div id="section5" class="section"><h2><a name="section5">API</a></h2>
<div id="subsection1" class="subsection"><h3><a name="subsection1">Accessors</a></h3>
<dl class="definitions">
<dt><a name="1"><b class="cmd">::crimp</b> <b class="method">channels</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns a list containing the names of the channels in the
<i class="arg">image</i>. The order of channels is the same as expected by the
<b class="method">remap</b> method.</p>
<p>The method supports all image types.</p></dd>
<dt><a name="2"><b class="cmd">::crimp</b> <b class="method">dimensions</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns the width and height of the <i class="arg">image</i> (in pixels).
The result is a 2-element list containing width and height, in this order.</p>
<p>The method supports all image types.</p></dd>
<dt><a name="3"><b class="cmd">::crimp</b> <b class="method">height</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns the height of the <i class="arg">image</i> (in pixels).</p>
<p>The method supports all image types.</p></dd>
<dt><a name="4"><b class="cmd">::crimp</b> <b class="method">histogram</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns a nested dictionary as its result.
The outer dictionary is indexed by the names of the
channels in the <i class="arg">image</i>. Its values, the inner
dictionaries, are indexed by pixel value. The associated
values are the number of pixels with that value.</p>
<p>The method supports all image types except &quot;grey32&quot;.
Under the current system the result would be a dictionary
with 2^32 keys and values, taking up, roughly, 192 GiByte of
memory in the worst case, and 96 GiByte in best case (all
counter values shared in a single object).</p></dd>
<dt><a name="5"><b class="cmd">::crimp</b> <b class="method">type</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns the type of the <i class="arg">image</i>.</p>
<p>The method supports all image types.</p></dd>
<dt><a name="6"><b class="cmd">::crimp</b> <b class="method">width</b> <i class="arg">image</i></a></dt>
<dd><p>This method returns the width of the <i class="arg">image</i> (in pixels).</p>
<p>The method supports all image types.</p></dd>
</dl>
</div>
<div id="subsection2" class="subsection"><h3><a name="subsection2">Manipulators</a></h3>
<dl class="definitions">
<dt><a name="7"><b class="cmd">::crimp</b> <b class="method">blank</b> <i class="arg">type</i> <i class="arg">width</i> <i class="arg">height</i> <i class="arg">value</i>...</a></dt>
<dd><p>This method returns a blank image of the given image type and dimensions.
The <i class="arg">value</i>s after the dimensions are the pixel values to fill the
pixels in the image's channels with, per its type.</p>
<p>This method currently support only the types <b class="const">rgb</b>, <b class="const">rgba</b>,
and <b class="const">grey8</b>.</p></dd>
<dt><a name="8"><b class="cmd">::crimp</b> <b class="method">blend</b> <i class="arg">foreground</i> <i class="arg">background</i> <i class="arg">alpha</i></a></dt>
<dd><p>This method takes two images of identical dimensions and a blending factor
<i class="arg">alpha</i> and returns an image which is a mix of both, with each pixel
blended per the formula</p>
<p><img alt="blend" src="./image/blend.png"></p>
<p>or, alternatively written</p>
<p><img alt="blend_alt" src="./image/blend_alt.png"></p>
<p>This means that the <i class="arg">foreground</i> is returned as is for &quot;<i class="arg">alpha</i> == 1&quot;,
and the <i class="arg">background</i> for &quot;<i class="arg">alpha</i> == 1&quot;. I.e. the argument <i class="arg">alpha</i>
controls the <i class="term">opacity</i> of the foreground, with <b class="const">1</b> and <b class="const">0</b>
standing for &quot;fully opaque&quot; and &quot;fully transparent&quot;, respectively.</p>
<p>The following combinations of fore- and background image types are supported:</p>
<pre class="example">
    Result = Foreground Background 
    ------   ---------- ---------- 
    grey8    grey8      grey8
    hsv      hsv        hsv
    rgb      rgb        grey8
    rgb      rgb        rgb
    rgb      rgb        rgba
    rgba     rgba       grey8
    rgba     rgba       rgb
    rgba     rgba       rgba
    ------   ---------- ----------
</pre>
</dd>
<dt><a name="9"><b class="cmd">::crimp</b> <b class="method">degamma</b> <i class="arg">image</i> <i class="arg">y</i></a></dt>
<dd><p>This method takes an image, runs it through an <b class="function">inverse gamma correction</b>
with parameter <i class="arg">y</i>, and returns the corrected image as it result.
This is an application of method <b class="method">remap</b>, using the mapping returned
by &quot;<b class="method">map degamma</b> <i class="arg">y</i>&quot;.
This method supports all image types supported by the method <b class="method">remap</b>.</p></dd>
<dt><a name="10"><b class="cmd">::crimp</b> <b class="method">expand const</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i> <span class="opt">?<i class="arg">value</i>...?</span></a></dt>
<dd></dd>
<dt><a name="11"><b class="cmd">::crimp</b> <b class="method">expand extend</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></dt>
<dd></dd>
<dt><a name="12"><b class="cmd">::crimp</b> <b class="method">expand mirror</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></dt>
<dd></dd>
<dt><a name="13"><b class="cmd">::crimp</b> <b class="method">expand replicate</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></dt>
<dd></dd>
<dt><a name="14"><b class="cmd">::crimp</b> <b class="method">expand wrap</b> <i class="arg">image</i> <i class="arg">ww</i> <i class="arg">hn</i> <i class="arg">we</i> <i class="arg">hs</i></a></dt>
<dd><p>This set of methods takes an image and expands it by adding a border.
The size of this border is specified by the four arguments <i class="arg">ww</i>,
<i class="arg">hn</i>, <i class="arg">we</i>, and <i class="arg">hs</i> which provide the number of pixels to
add at the named edge. See the image below for a graphical
representation.</p>
<p><img alt="border" src="./image/border.png"></p>
<p>The contents of the border's pixels are specified via the border type,
the first argument after <b class="method">expand</b>, as per the list below.</p>
<dl class="definitions">
<dt><b class="method">const</b></dt>
<dd><p>The additional <i class="arg">value</i>s specify the values to use for the color
channels of the image. Values beyond the number of channels in the
image are ignored.
Missing values are generated by replicating the last value, except for
the alpha channel, which will be set to <b class="const">255</b>. If no values are
present they default to <b class="const">0</b>.</p></dd>
<dt><b class="method">extend</b></dt>
<dd><p>This is a combination of <b class="method">mirror</b> and <b class="method">replicate</b>.  The
outside pixels are the result of subtracting the outside pixel for
<b class="method">mirror</b> from the outside pixel for <b class="method">replicate</b> (and
clamping to the range [0...255]).</p></dd>
<dt><b class="method">mirror</b></dt>
<dd><p>The outside pixels take the value of the associated inside pixels,
found by reflecting its coordinates along the relevant edges.</p></dd>
<dt><b class="method">replicate</b></dt>
<dd><p>The outside pixels take the value of the associated edge pixels, i.e.
replicating them into the border.</p></dd>
<dt><b class="method">wrap</b></dt>
<dd><p>The outside pixels take the value of the associated inside pixels,
found by toroidial (cyclic) wrapping its coordinates along the
relevant edges. This is also called tiling.</p></dd>
</dl></dd>
<dt><a name="15"><b class="cmd">::crimp</b> <b class="method">gamma</b> <i class="arg">image</i> <i class="arg">y</i></a></dt>
<dd><p>This method takes an image, runs it through a <b class="function">gamma correction</b> with
parameter <i class="arg">y</i>, and returns the corrected image as it result.
This is an application of method <b class="method">remap</b>, using the mapping returned
by &quot;<b class="method">map gamma</b> <i class="arg">y</i>&quot;.
This method supports all image types supported by the method <b class="method">remap</b>.</p></dd>
<dt><a name="16"><b class="cmd">::crimp</b> <b class="method">invert</b> <i class="arg">image</i></a></dt>
<dd><p>This method takes an image, runs it through the <b class="function">inverse</b> function, and
returns the modified image as it result.
This is an application of method <b class="method">remap</b>, using the mapping returned
by &quot;<b class="method">map inverse</b>&quot;.
This method supports all image types supported by the method <b class="method">remap</b>.</p></dd>
<dt><a name="17"><b class="cmd">::crimp</b> <b class="method">matrix</b> <i class="arg">image</i> <i class="arg">matrix</i></a></dt>
<dd><p>This method takes an image and a 3x3 matrix specified as nested Tcl list
(row major order), applies the projective transform represented by the matrix
to the image and returns the transformed image as its result.</p>
<p>Notes: It is currently unclear how the output pixel is computed (nearest
neighbour, bilinear, etc.) (code inherited from AMG). This requires more
reading, and teasing things apart. The transfomred image is clipped to the
dimensions of the input image, i.e. pixels from the input may be lost, and
pixels in the output may be unset as their input would come from outside of
the input.</p>
<p>The operation supports only images of type <b class="const">rgba</b>, and returns images of
the same type.</p></dd>
<dt><a name="18"><b class="cmd">::crimp</b> <b class="method">over</b> <i class="arg">foreground</i> <i class="arg">background</i></a></dt>
<dd><p>This method is similar to <b class="method">blend</b> above, except that there is no global
blending parameter. This information is taken from the &quot;alpha&quot; channel of the
<i class="arg">foreground</i> image instead. The blending formula is the same, except that
the alpha parameter is now a per-pixel value, and not constant across the image.</p>
<p>Due to the need for an alpha channel the <i class="arg">foreground</i> has to be of
type <b class="const">rgba</b>. For the <i class="arg">background</i> image the types <b class="const">rgb</b> and
<b class="const">rgba</b> are supported.</p></dd>
<dt><a name="19"><b class="cmd">::crimp</b> <b class="method">psychedelia</b> <i class="arg">width</i> <i class="arg">height</i> <i class="arg">frames</i></a></dt>
<dd><p>This method creates an <b class="const">rgba</b> image of the specified dimensions according
to an algorithm devised by Andrew M. Goth. The <i class="arg">frames</i> argument specifies
how many images are in the series.</p>
<p><em>Attention:</em> This method keeps internal global state, ensuring that
each call returns a slightly different image. Showing a series of such images
as animation provides an effect similar to a lava lamp or hallucination.</p></dd>
<dt><a name="20"><b class="cmd">::crimp</b> <b class="method">remap</b> <i class="arg">image</i> <i class="arg">map</i>...</a></dt>
<dd><p>This method is the core primitive for the per-pixel transformation of images,
with each pixel (and channels within, if any) handled independently of all others.
Applications of this operator provided by this package are (inverse) gamma
correction, pixel inversion, and solarization. Many more are possible,
especially when considering other colorspaces like HSV. There, for example,
it is possible change the saturation of pixels, or shift the hue in arbitrary
manner.</p>
<p>Beyond the input <i class="arg">image</i> to transform one or more <i class="term">maps</i> are specified
which define how each pixel value in the input is mapped to a pixel value in the
output. The command will accept at most that many maps as the input image has channels.
If there are less maps than channel the last map specified is replicated to cover
the other channels. An exception of this is the handling of the alpha channel,
should the input image have such. There a missing map is handle as <b class="function">identity</b>,
i.e. the channel copied as is, without changes.</p>
<p>The maps are not Tcl data structures, but images themselves.
They have to be of type <b class="const">grey8</b>, and be of dimension 256x1 (width by height).</p>
<p>The <b class="method">crimp map ...</b> methods are sources for a number of predefined maps.
And the <b class="method">read tcl</b> method allows the construction of maps from Tcl data
structures, namely nested lists.</p>
<p>This method supports all image types with one or more single-byte channels,
i.e. all but <b class="const">grey16</b>, <b class="const">grey32</b>, and <b class="const">bw</b>.</p></dd>
<dt><a name="21"><b class="cmd">::crimp</b> <b class="method">setalpha</b> <i class="arg">image</i> <i class="arg">mask</i></a></dt>
<dd><p>This command takes two images, the input and a <i class="arg">mask</i>, and returns
an image as result in which the mask is the alpha channel of the input.
The result is therefore always of type <b class="const">rgba</b>, as the only type
supporting an alpha channel.</p>
<p>The input image can be of type <b class="const">rgb</b> or <b class="const">rgba</b>.
In case of the latter the existing alpha channel is replaced,
in case of the former an alpha channel is added.</p>
<p>For the mask images of type <b class="const">grey8</b> and <b class="const">rgba</b> are accepted.
In the case of the latter the mask's alpha channel is used as the new alpha channel,
in case of the former the mask itself is used.</p></dd>
<dt><a name="22"><b class="cmd">::crimp</b> <b class="method">solarize</b> <i class="arg">image</i> <i class="arg">threshold</i></a></dt>
<dd><p>This method takes an image, runs it through the <b class="function">solarize</b> function with
parameter <i class="arg">threshold</i>, and returns the modified image as it result.
This is an application of method <b class="method">remap</b>, using the mapping returned
by &quot;<b class="method">map solarize</b> <i class="arg">threshold</i>&quot;.
This method supports all image types supported by the method <b class="method">remap</b>.</p></dd>
<dt><a name="23"><b class="cmd">::crimp</b> <b class="method">wavy</b> <i class="arg">image</i> <i class="arg">offset</i> <i class="arg">adj1</i> <i class="arg">adjb</i></a></dt>
<dd><p>This method processes the input <i class="arg">image</i> according to an algorithm devised by
Andrew M. Goth, according to the three parameters <i class="arg">offset</i>, <i class="arg">adj1</i>, and
<i class="arg">adjb</i>, and returns the modified image as its result.</p>
<p>The operation supports only images of type <b class="const">rgba</b>, and returns images of
the same type.</p></dd>
<dt><a name="24"><b class="cmd">::crimp</b> <b class="method">flip horizontal</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="25"><b class="cmd">::crimp</b> <b class="method">flip transpose</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="26"><b class="cmd">::crimp</b> <b class="method">flip transverse</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="27"><b class="cmd">::crimp</b> <b class="method">flip vertical</b> <i class="arg">image</i></a></dt>
<dd><p>This set of methods performs mirroring along the horizontal, vertical and diagonal
axes of the input <i class="arg">image</i>, returning the mirrored image as their output.
Transpose mirrors along the main diagonal, transverse along the secondary diagonal.
These two methods also exchange width and height of the image in the output.</p>
<p>The methods currently support the image types <b class="const">rgb</b>, <b class="const">rgba</b>,
<b class="const">hsv</b>, and <b class="const">grey8</b>.</p></dd>
</dl>
</div>
<div id="subsection3" class="subsection"><h3><a name="subsection3">Converters</a></h3>
<dl class="definitions">
<dt><a name="28"><b class="cmd">::crimp</b> <b class="method">convert 2grey8</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="29"><b class="cmd">::crimp</b> <b class="method">convert 2hsv</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="30"><b class="cmd">::crimp</b> <b class="method">convert 2rgba</b> <i class="arg">image</i></a></dt>
<dd></dd>
<dt><a name="31"><b class="cmd">::crimp</b> <b class="method">convert 2rgb</b> <i class="arg">image</i></a></dt>
<dd><p>This set of methods all convert their input <i class="arg">image</i> to the
specified type and returns it as their result.</p>
<p>The converters returning a <b class="const">grey8</b> image support <b class="const">rgb</b> and
<b class="const">rgba</b> as their input, using the ITU-R 601-2 luma transform to
merge the three color channels</p>
<p>The converters to HSV support <b class="const">rgb</b> and <b class="const">rgba</b> as their
input as well.</p>
<p>The conversion to <b class="const">rgba</b> accepts only <b class="const">hsv</b> as input,
adding a blank (fully opaque) alpha channel. For more control over the
contents of an image's alpha channel see the methods <b class="method">setalpha</b>
and <b class="method">join rgba</b>.</p>
<p>At last, the conversion to <b class="const">rgb</b> accepts both <b class="const">rgba</b> and
<b class="const">hsv</b> images as input.</p></dd>
<dt><a name="32"><b class="cmd">::crimp</b> <b class="method">join 2hsv</b> <i class="arg">hueImage</i> <i class="arg">satImage</i> <i class="arg">valImage</i></a></dt>
<dd></dd>
<dt><a name="33"><b class="cmd">::crimp</b> <b class="method">join 2rgba</b> <i class="arg">redImage</i> <i class="arg">greenImage</i> <i class="arg">blueImage</i> <i class="arg">alphaImage</i></a></dt>
<dd></dd>
<dt><a name="34"><b class="cmd">::crimp</b> <b class="method">join 2rgb</b> <i class="arg">redImage</i> <i class="arg">greenImage</i> <i class="arg">blueImage</i></a></dt>
<dd><p>This set of methods is the complement of method <b class="method">split</b>. Each
take a set of <b class="const">grey8</b> images and fuse them together into an
image of the given type, with each input image becoming one channel of
the fusing result, which is returned as the result of the command. All
input images have to have the same dimensions.</p></dd>
<dt><a name="35"><b class="cmd">::crimp</b> <b class="method">split</b> <i class="arg">image</i></a></dt>
<dd><p>This method takes an image of one of the multi-channel types,
i.e. <b class="const">rgb</b>, const rgba], and <b class="const">hsv</b> and returns a list of
<b class="const">grey8</b> images, each of which contains the contents of one of
the channels found in the input image.</p>
<p>The channel images in the result are provided in the same order as
they are accepted by the complementary <b class="method">join</b> method, see
above.</p></dd>
</dl>
</div>
<div id="subsection4" class="subsection"><h3><a name="subsection4">I/O commands</a></h3>
<dl class="definitions">
<dt><a name="36"><b class="cmd">::crimp</b> <b class="method">read tcl</b> <i class="arg">pixelmatrix</i></a></dt>
<dd><p>This method takes the <i class="arg">pixelmatrix</i>, a list of rows, each row
a list of pixel values in the domain [0..255] and returns an
image of type <b class="const">grey8</b> whose height is the number of rows, i.e.
the length of the outer list, and whose width is the maximum length
found among the inner lists. Rows whose inner list is shorter than
the maximum length are padded with black pixels, i.e. a pixel
value of <b class="const">255</b>.</p></dd>
<dt><a name="37"><b class="cmd">::crimp</b> <b class="method">read tk</b> <i class="arg">photo</i></a></dt>
<dd><p>This method returns an image of type <b class="const">rgba</b> containing the data
from the specified Tk <i class="arg">photo</i> image.</p></dd>
<dt><a name="38"><b class="cmd">::crimp</b> <b class="method">write 2tk</b> <i class="arg">photo</i> <i class="arg">image</i></a></dt>
<dd><p>This method writes the input <i class="arg">image</i> to the specified Tk
<i class="arg">photo</i> image.</p>
<p>The method supports the witing of <b class="const">rgb</b>, <b class="const">rgba</b>,
and <b class="const">grey8</b> images.</p></dd>
</dl>
</div>
<div id="subsection5" class="subsection"><h3><a name="subsection5">Support</a></h3>
<dl class="definitions">
<dt><a name="39"><b class="cmd">::crimp</b> <b class="method">map</b> <i class="arg">arg</i>...</a></dt>
<dd><p>This method accepts the same sub-methods and arguments as are accepted
by the <b class="method">table</b> method below. In contrast to <b class="method">table</b>
the result is not a list of values, but a map image directly suitable
as argument to the <b class="method">remap</b> method.</p></dd>
<dt><a name="40"><b class="cmd">::crimp</b> <b class="method">table degamma</b> <i class="arg">y</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running
the values 0 to 255 through the <b class="function">inverse gamma correction</b> with
parameter <i class="arg">y</i>.
This inverse correction, defined in the domain of [0..1]
for both argument and result, is defined as:</p>
<p><img alt="gamma_inv" src="./image/gamma_inv.png"></p>
<p>Scaling of argument and result into the domain [0..255]
of pixel values, and rounding results to the nearest integer,
causes the actual definition used to be</p>
<p><img alt="scaled_gamma_inv" src="./image/scaled_gamma_inv.png"></p></dd>
<dt><a name="41"><b class="cmd">::crimp</b> <b class="method">table gainw</b> <i class="arg">gain</i> <i class="arg">bias</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running
the values 0 to 255 through a simple linear function with parameters
<i class="arg">gain</i> and <i class="arg">bias</i>. The results are rounded to the nearest
integer and forced into the domain [0..255] by wrapping them
around (modulo), making the definition:</p>
<p><img alt="linear_wrap" src="./image/linear_wrap.png"></p></dd>
<dt><a name="42"><b class="cmd">::crimp</b> <b class="method">table gain</b> <i class="arg">gain</i> <i class="arg">bias</i></a></dt>
<dd><p>This method is like <b class="method">gainw</b>, except that it deals with results
out of the domain [0..255] by clamping them to 0 and 255
respectively instead of wrapping around. I.e. its definition is</p>
<p><img alt="linear_clamp" src="./image/linear_clamp.png"></p></dd>
<dt><a name="43"><b class="cmd">::crimp</b> <b class="method">table gamma</b> <i class="arg">y</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running
the values 0 to 255 through the <b class="function">gamma correction</b> with
parameter <i class="arg">y</i>.
This correction, defined in the domain of [0..1] for both
argument and result, is defined as:</p>
<p><img alt="gamma" src="./image/gamma.png"></p>
<p>Scaling of argument and result into the domain [0..255]
of pixel values, and rounding results to the nearest integer,
causes the actual definition used to be</p>
<p><img alt="scaled_gamma" src="./image/scaled_gamma.png"></p></dd>
<dt><a name="44"><b class="cmd">::crimp</b> <b class="method">table identity</b></a></dt>
<dd><p>This method returns a list of 256 values, the result of running
the values 0 to 255 through the <b class="function">identity</b> function, defined as</p>
<p><img alt="identity" src="./image/identity.png"></p></dd>
<dt><a name="45"><b class="cmd">::crimp</b> <b class="method">table invers</b></a></dt>
<dd><p>This method returns a list of 256 values, the result of running
the values 0 to 255 through the <b class="function">inverse</b> function, defined as</p>
<p><img alt="inverse" src="./image/inverse.png"></p></dd>
<dt><a name="46"><b class="cmd">::crimp</b> <b class="method">table solarize</b> <i class="arg">threshold</i></a></dt>
<dd><p>This method returns a list of 256 values, the result of running
the values 0 to 255 through the <b class="function">solarize</b> function, with
parameter <i class="arg">threshold</i>. The function is defined as:</p>
<p><img alt="solarize" src="./image/solarize.png"></p>
<p>Note how the function is the <b class="function">identity</b> for values under the
threshold, and the <b class="function">inverse</b> for values at and above it.</p></dd>
</dl>
</div>
</div>
<div id="keywords" class="section"><h2><a name="keywords">Keywords</a></h2>
<p>affine transform, alpha, alpha blending, alpha channel, blending, channels, composite blending, composition, const expansion, cyclic wrap expansion, dimensions, expansion, extend expansion, flip, gamma correction, histogram, image, inversion, matrix, mirror expansion, photo, pixel mapping, projective transform, remapping, replicate edge expansion, sabatier effect, solarization, toroidal wrap expansion, transform, wrap expansion</p>
</div>
<div id="copyright" class="section"><h2><a name="copyright">Copyright</a></h2>
<p>Copyright &copy; 2010 Andreas Kupries<br>
Copyright &copy; 2010 Documentation, Andreas Kupries</p>
</div>
</div></body></html>
