# See window.crimp for the derivation of the math.

crimp_primitive window_rgba {
    image_rgba image
} image {
    crimp_image* result = crimp_new_like (image);

    int h = crimp_h (image);
    int w = crimp_w (image);

    int x, y, idx;
    ITER (unsigned char,  incursor,  image);
    ITER (unsigned char, outcursor, result);

    for (y = 0; y < h; y++) {
	double dy = (2*y - (double)h + 1) / (double)h;
        double wy = 1.0 - dy * dy;

	for (x = 0; x < w; x++, NEXTN (incursor,4), NEXTN (outcursor,4)) {
	    int zr;
	    int zg;
	    int zb;
	    int za;
	    int ar = CURRENTN (incursor,0);
	    int ag = CURRENTN (incursor,1);
	    int ab = CURRENTN (incursor,2);
	    int aa = CURRENTN (incursor,3);

	    double dx = (2*x - (double)w + 1) / (double)w;
	    double wx = 1.0 - dx * dx;

	    zr = ar * wx * wy;
	    zg = ag * wx * wy;
	    zb = ab * wx * wy;
	    za = aa;

	    CURRENTN (outcursor,0) = zr;
	    CURRENTN (outcursor,1) = zg;
	    CURRENTN (outcursor,2) = zb;
	    CURRENTN (outcursor,3) = za;
	}
    }

    return result;
}

# - -- --- ----- -------- -------------
# vim: set sts=4 sw=4 tw=80 et ft=tcl:
#
# Local Variables:
# mode: tcl
# fill-column: 78
# End:
#
