cannyinternal
Tcl_Obj* imageXObj
Tcl_Obj* imageYObj
double high
double low

 
crimp_image* imageX;
crimp_image* imageY;
crimp_image* temp;
crimp_image* result;
int          x, y;
double a ,max,sum =0.0f;

crimp_input (imageXObj, imageX, float);
crimp_input (imageYObj, imageY, float);

temp   = crimp_new_like (imageX);
result = crimp_new_like (imageX);



/*
 * Initialization, of border pixels not written to by the
 * later phases.
 */

for (y = 0; y < result->h; y++) {
    FLOATP (temp   ,           0, y) = BLACK;
	FLOATP (result ,           0, y) = BLACK;
	FLOATP (temp   , result->w-1, y) = BLACK;
	FLOATP (result , result->w-1, y) = BLACK;
}

for (x = 0; x < result->w; x++) {
    FLOATP (temp   , x,          0) = BLACK;
	FLOATP (result , x,          0) = BLACK;
	FLOATP (temp   , x,result->h-1) = BLACK;
	FLOATP (result , x,result->h-1) = BLACK;
}



for (y = 1; y < result->h-1; y++) {
    for (x = 1; x < result->w-1; x++) {
	     
		 /*
	     * Non-maxima suppression.
	     */
	 
		 a = FLOATP (imageY , x, y) ;
		 if      ( ((a > 67.5f)  && (a <= 112.5f) ) ||
        		   ((a > 247.5f) && (a <= 292.5f) ) ) 		

         /* The gradient runs mostly vertical, up or down. Take maximum
	     * from the north/south neighbours.
	     */
				   
		 max = FLOATP (imageX ,x , y+1)   > FLOATP (imageX ,x , y-1 ) 
		 ? FLOATP (imageX ,x , y+1)   
		 : FLOATP (imageX ,x , y-1 ) ;
		
		 else if ( ((a > 112.5f) && (a <= 157.5f) )||
            	  ((a > 292.5f) && (a <= 337.5f) ) )   
				  
		 /* The gradient runs mostly along the main diagonal (up-left /
	     * down-right). Take maximum from the north-west/south-east
	     * neighbours.
	     */		  
				  
		 max = FLOATP (imageX ,x-1 , y-1) > FLOATP (imageX ,x+1 , y+1 ) 
		 ? FLOATP (imageX ,x-1 , y-1)   
		 : FLOATP (imageX ,x+1 , y+1 ) ;
		 
		 else if ( ((a > 22.5f) && (a <= 67.5f )  )|| 
		          ((a > 202.5f) && (a <= 247.5f )) )   
				  
         /* The gradient runs mostly along the secondary diagonal (up-right
	     *  / down-left). Take maximum from the north-east/south-west
	     *  neighbours.
	     */				 
				 
		 	 max = FLOATP (imageX ,x+1 , y-1) > FLOATP (imageX ,x-1 , y+1 ) 
			 ? FLOATP (imageX ,x+1 , y-1)   
			 : FLOATP (imageX ,x-1 , y+1 ) ;
		 
		else 
		
		 /* The gradient runs mostly horizontal, left or right. Take
	     * maximum from the east/west neighbours.
	     */
		      max = FLOATP (imageX ,x+1 , y)  > FLOATP (imageX ,x-1 , y ) 
			  ? FLOATP (imageX ,x+1 , y) 
			  : FLOATP (imageX ,x-1 , y ) ;
			
		 /*  Double Thresholding    	
		 */
			
		 if ( max > FLOATP (imageX ,x , y) )     
		        FLOATP (temp, x, y) = BLACK; 
		 else  
                FLOATP (temp, x, y) = FLOATP (imageX, x, y) ;
	     	 
		if (( FLOATP (temp  , x, y) > low) && (FLOATP( temp, x, y) < high ) ) {
		     FLOATP (result, x, y) = BLACK ;
			 FLOATP (temp  ,  x, y) = WHITE ;
			 
		}	 
	    else if ( FLOATP( temp, x, y) <= low ) {
		     FLOATP (result, x, y) = BLACK;	
			 FLOATP (temp  , x, y) = BLACK ;
		}	 
        else {
             FLOATP (result, x, y) = WHITE ;	
			 FLOATP (temp  , x, y) = BLACK ;
			 
		}	 
	}
}

     /*
      * Hysteris thresholding post-processing through connectivity analysis
      * activating all WEAK pixels of temp if they can be connected to a
      * STRONG pixel of result .
      */

for (y = 1; y < result->h - 1; y++) {
    for (x = 1; x < result->w - 1; x++) {
	     if ( FLOATP (temp, x, y) == WHITE ) {
	         if( (FLOATP (result, x-1, y-1) == WHITE ) ||
	             (FLOATP (result, x-1, y  ) == WHITE ) ||
				 (FLOATP (result, x,   y-1) == WHITE ) ||
				 (FLOATP (result, x+1, y-1) == WHITE ) ) {

		     FLOATP (result, x, y) = WHITE; 
	        } else {
		     FLOATP (result, x, y) = BLACK;
	        }
	    }
    }
}

for (y = result->h - 2; y > 0; y--) {
    for (x = result->w - 2; x > 0; x--) {
	     if ( FLOATP (temp, x, y) == WHITE ) {
	         if( (FLOATP (result, x-1, y+1) == WHITE ) ||
		         (FLOATP (result, x,   y+1) == WHITE ) ||
		         (FLOATP (result, x+1, y  ) == WHITE ) ||
		         (FLOATP (result, x+1, y+1) == WHITE ) ) {

		     FLOATP (result, x, y) = WHITE;
	         } else {
		     FLOATP (result, x, y) = BLACK;
	        }
	    }
    }
}
	
	
crimp_del (temp);	
	
Tcl_SetObjResult(interp, crimp_new_image_obj (result));
return TCL_OK;


/* vim: set sts=4 sw=4 tw=80 et ft=c: */
/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
